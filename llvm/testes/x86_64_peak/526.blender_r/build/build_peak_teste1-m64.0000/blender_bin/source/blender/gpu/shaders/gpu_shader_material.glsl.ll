; ModuleID = 'blender_bin/source/blender/gpu/shaders/gpu_shader_material.glsl.c'
source_filename = "blender_bin/source/blender/gpu/shaders/gpu_shader_material.glsl.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@datatoc_gpu_shader_material_glsl_size = dso_local local_unnamed_addr global i32 58099, align 4
@datatoc_gpu_shader_material_glsl = dso_local local_unnamed_addr global [58100 x i8] c"\0Afloat exp_blender(float f)\0A{\0A\09return pow(2.71828182846, f);\0A}\0A\0Afloat compatible_pow(float x, float y)\0A{\0A\09if(y == 0.0) /* x^0 -> 1, including 0^0 */\0A\09\09return 1.0;\0A\0A\09/* glsl pow doesn't accept negative x */\0A\09if(x < 0.0) {\0A\09\09if(mod(-y, 2.0) == 0.0)\0A\09\09\09return pow(-x, y);\0A\09\09else\0A\09\09\09return -pow(-x, y);\0A\09}\0A\09else if(x == 0.0)\0A\09\09return 0.0;\0A\0A\09return pow(x, y);\0A}\0A\0Avoid rgb_to_hsv(vec4 rgb, out vec4 outcol)\0A{\0A\09float cmax, cmin, h, s, v, cdelta;\0A\09vec3 c;\0A\0A\09cmax = max(rgb[0], max(rgb[1], rgb[2]));\0A\09cmin = min(rgb[0], min(rgb[1], rgb[2]));\0A\09cdelta = cmax-cmin;\0A\0A\09v = cmax;\0A\09if (cmax!=0.0)\0A\09\09s = cdelta/cmax;\0A\09else {\0A\09\09s = 0.0;\0A\09\09h = 0.0;\0A\09}\0A\0A\09if (s == 0.0) {\0A\09\09h = 0.0;\0A\09}\0A\09else {\0A\09\09c = (vec3(cmax, cmax, cmax) - rgb.xyz)/cdelta;\0A\0A\09\09if (rgb.x==cmax) h = c[2] - c[1];\0A\09\09else if (rgb.y==cmax) h = 2.0 + c[0] -  c[2];\0A\09\09else h = 4.0 + c[1] - c[0];\0A\0A\09\09h /= 6.0;\0A\0A\09\09if (h<0.0)\0A\09\09\09h += 1.0;\0A\09}\0A\0A\09outcol = vec4(h, s, v, rgb.w);\0A}\0A\0Avoid hsv_to_rgb(vec4 hsv, out vec4 outcol)\0A{\0A\09float i, f, p, q, t, h, s, v;\0A\09vec3 rgb;\0A\0A\09h = hsv[0];\0A\09s = hsv[1];\0A\09v = hsv[2];\0A\0A\09if(s==0.0) {\0A\09\09rgb = vec3(v, v, v);\0A\09}\0A\09else {\0A\09\09if(h==1.0)\0A\09\09\09h = 0.0;\0A\09\09\0A\09\09h *= 6.0;\0A\09\09i = floor(h);\0A\09\09f = h - i;\0A\09\09rgb = vec3(f, f, f);\0A\09\09p = v*(1.0-s);\0A\09\09q = v*(1.0-(s*f));\0A\09\09t = v*(1.0-(s*(1.0-f)));\0A\09\09\0A\09\09if (i == 0.0) rgb = vec3(v, t, p);\0A\09\09else if (i == 1.0) rgb = vec3(q, v, p);\0A\09\09else if (i == 2.0) rgb = vec3(p, v, t);\0A\09\09else if (i == 3.0) rgb = vec3(p, q, v);\0A\09\09else if (i == 4.0) rgb = vec3(t, p, v);\0A\09\09else rgb = vec3(v, p, q);\0A\09}\0A\0A\09outcol = vec4(rgb, hsv.w);\0A}\0A\0Afloat srgb_to_linearrgb(float c)\0A{\0A\09if(c < 0.04045)\0A\09\09return (c < 0.0) ? 0.0: c * (1.0 / 12.92);\0A\09else\0A\09\09return pow((c + 0.055)*(1.0/1.055), 2.4);\0A}\0A\0Afloat linearrgb_to_srgb(float c)\0A{\0A\09if(c < 0.0031308)\0A\09\09return (c < 0.0) ? 0.0: c * 12.92;\0A\09else\0A\09\09return 1.055 * pow(c, 1.0/2.4) - 0.055;\0A}\0A\0Avoid srgb_to_linearrgb(vec4 col_from, out vec4 col_to)\0A{\0A\09col_to.r = srgb_to_linearrgb(col_from.r);\0A\09col_to.g = srgb_to_linearrgb(col_from.g);\0A\09col_to.b = srgb_to_linearrgb(col_from.b);\0A\09col_to.a = col_from.a;\0A}\0A\0Avoid linearrgb_to_srgb(vec4 col_from, out vec4 col_to)\0A{\0A\09col_to.r = linearrgb_to_srgb(col_from.r);\0A\09col_to.g = linearrgb_to_srgb(col_from.g);\0A\09col_to.b = linearrgb_to_srgb(col_from.b);\0A\09col_to.a = col_from.a;\0A}\0A\0A#define M_PI 3.14159265358979323846\0A#define M_1_PI 0.31830988618379069\0A\0A/*********** SHADER NODES ***************/\0A\0Avoid vcol_attribute(vec4 attvcol, out vec4 vcol)\0A{\0A\09vcol = vec4(attvcol.x/255.0, attvcol.y/255.0, attvcol.z/255.0, 1.0);\0A}\0A\0Avoid uv_attribute(vec2 attuv, out vec3 uv)\0A{\0A\09uv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0);\0A}\0A\0Avoid geom(vec3 co, vec3 nor, mat4 viewinvmat, vec3 attorco, vec2 attuv, vec4 attvcol, out vec3 global, out vec3 local, out vec3 view, out vec3 orco, out vec3 uv, out vec3 normal, out vec4 vcol, out float vcol_alpha, out float frontback)\0A{\0A\09local = co;\0A\09view = (gl_ProjectionMatrix[3][3] == 0.0)? normalize(local): vec3(0.0, 0.0, -1.0);\0A\09global = (viewinvmat*vec4(local, 1.0)).xyz;\0A\09orco = attorco;\0A\09uv_attribute(attuv, uv);\0A\09normal = -normalize(nor);\09/* blender render normal is negated */\0A\09vcol_attribute(attvcol, vcol);\0A\09vcol_alpha = attvcol.a;\0A\09frontback = (gl_FrontFacing)? 1.0: 0.0;\0A}\0A\0Avoid mapping(vec3 vec, mat4 mat, vec3 minvec, vec3 maxvec, float domin, float domax, out vec3 outvec)\0A{\0A\09outvec = (mat * vec4(vec, 1.0)).xyz;\0A\09if(domin == 1.0)\0A\09\09outvec = max(outvec, minvec);\0A\09if(domax == 1.0)\0A\09\09outvec = min(outvec, maxvec);\0A}\0A\0Avoid camera(vec3 co, out vec3 outview, out float outdepth, out float outdist)\0A{\0A\09outdepth = abs(co.z);\0A\09outdist = length(co);\0A\09outview = normalize(co);\0A}\0A\0Avoid lamp(vec4 col, vec3 lv, float dist, vec3 shadow, float visifac, out vec4 outcol, out vec3 outlv, out float outdist, out vec4 outshadow, out float outvisifac)\0A{\0A\09outcol = col;\0A\09outlv = lv;\0A\09outdist = dist;\0A\09outshadow = vec4(shadow, 1.0);\0A\09outvisifac = visifac;\0A}\0A\0Avoid math_add(float val1, float val2, out float outval)\0A{\0A\09outval = val1 + val2;\0A}\0A\0Avoid math_subtract(float val1, float val2, out float outval)\0A{\0A\09outval = val1 - val2;\0A}\0A\0Avoid math_multiply(float val1, float val2, out float outval)\0A{\0A\09outval = val1 * val2;\0A}\0A\0Avoid math_divide(float val1, float val2, out float outval)\0A{\0A\09if (val2 == 0.0)\0A\09\09outval = 0.0;\0A\09else\0A\09\09outval = val1 / val2;\0A}\0A\0Avoid math_sine(float val, out float outval)\0A{\0A\09outval = sin(val);\0A}\0A\0Avoid math_cosine(float val, out float outval)\0A{\0A\09outval = cos(val);\0A}\0A\0Avoid math_tangent(float val, out float outval)\0A{\0A\09outval = tan(val);\0A}\0A\0Avoid math_asin(float val, out float outval)\0A{\0A\09if (val <= 1.0 && val >= -1.0)\0A\09\09outval = asin(val);\0A\09else\0A\09\09outval = 0.0;\0A}\0A\0Avoid math_acos(float val, out float outval)\0A{\0A\09if (val <= 1.0 && val >= -1.0)\0A\09\09outval = acos(val);\0A\09else\0A\09\09outval = 0.0;\0A}\0A\0Avoid math_atan(float val, out float outval)\0A{\0A\09outval = atan(val);\0A}\0A\0Avoid math_pow(float val1, float val2, out float outval)\0A{\0A\09if (val1 >= 0.0) {\0A\09\09outval = compatible_pow(val1, val2);\0A\09}\0A\09else {\0A\09\09float val2_mod_1 = mod(abs(val2), 1.0);\0A\0A\09\09if (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\0A\09\09\09outval = compatible_pow(val1, floor(val2 + 0.5));\0A\09\09else\0A\09\09\09outval = 0.0;\0A\09}\0A}\0A\0Avoid math_log(float val1, float val2, out float outval)\0A{\0A\09if(val1 > 0.0  && val2 > 0.0)\0A\09\09outval= log2(val1) / log2(val2);\0A\09else\0A\09\09outval= 0.0;\0A}\0A\0Avoid math_max(float val1, float val2, out float outval)\0A{\0A\09outval = max(val1, val2);\0A}\0A\0Avoid math_min(float val1, float val2, out float outval)\0A{\0A\09outval = min(val1, val2);\0A}\0A\0Avoid math_round(float val, out float outval)\0A{\0A\09outval= floor(val + 0.5);\0A}\0A\0Avoid math_less_than(float val1, float val2, out float outval)\0A{\0A\09if(val1 < val2)\0A\09\09outval = 1.0;\0A\09else\0A\09\09outval = 0.0;\0A}\0A\0Avoid math_greater_than(float val1, float val2, out float outval)\0A{\0A\09if(val1 > val2)\0A\09\09outval = 1.0;\0A\09else\0A\09\09outval = 0.0;\0A}\0A\0Avoid math_modulo(float val1, float val2, out float outval)\0A{\0A\09if (val2 == 0.0)\0A\09\09outval = 0.0;\0A\09else\0A\09\09outval = mod(val1, val2);\0A}\0A\0Avoid math_abs(float val1, out float outval)\0A{\0A    outval = abs(val1);\0A}\0A\0Avoid squeeze(float val, float width, float center, out float outval)\0A{\0A\09outval = 1.0/(1.0 + pow(2.71828183, -((val-center)*width)));\0A}\0A\0Avoid vec_math_add(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\0A{\0A\09outvec = v1 + v2;\0A\09outval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\0A}\0A\0Avoid vec_math_sub(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\0A{\0A\09outvec = v1 - v2;\0A\09outval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\0A}\0A\0Avoid vec_math_average(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\0A{\0A\09outvec = v1 + v2;\0A\09outval = length(outvec);\0A\09outvec = normalize(outvec);\0A}\0A\0Avoid vec_math_dot(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\0A{\0A\09outvec = vec3(0, 0, 0);\0A\09outval = dot(v1, v2);\0A}\0A\0Avoid vec_math_cross(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\0A{\0A\09outvec = cross(v1, v2);\0A\09outval = length(outvec);\0A}\0A\0Avoid vec_math_normalize(vec3 v, out vec3 outvec, out float outval)\0A{\0A\09outval = length(v);\0A\09outvec = normalize(v);\0A}\0A\0Avoid vec_math_negate(vec3 v, out vec3 outv)\0A{\0A\09outv = -v;\0A}\0A\0Avoid normal(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\0A{\0A\09outnor = nor;\0A\09outdot = -dot(dir, nor);\0A}\0A\0Avoid curves_vec(float fac, vec3 vec, sampler2D curvemap, out vec3 outvec)\0A{\0A\09outvec.x = texture2D(curvemap, vec2((vec.x + 1.0)*0.5, 0.0)).x;\0A\09outvec.y = texture2D(curvemap, vec2((vec.y + 1.0)*0.5, 0.0)).y;\0A\09outvec.z = texture2D(curvemap, vec2((vec.z + 1.0)*0.5, 0.0)).z;\0A\0A\09if (fac != 1.0)\0A\09\09outvec = (outvec*fac) + (vec*(1.0-fac));\0A\0A}\0A\0Avoid curves_rgb(float fac, vec4 col, sampler2D curvemap, out vec4 outcol)\0A{\0A\09outcol.r = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.r, 0.0)).a, 0.0)).r;\0A\09outcol.g = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.g, 0.0)).a, 0.0)).g;\0A\09outcol.b = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.b, 0.0)).a, 0.0)).b;\0A\0A\09if (fac != 1.0)\0A\09\09outcol = (outcol*fac) + (col*(1.0-fac));\0A\0A\09outcol.a = col.a;\0A}\0A\0Avoid set_value(float val, out float outval)\0A{\0A\09outval = val;\0A}\0A\0Avoid set_rgb(vec3 col, out vec3 outcol)\0A{\0A\09outcol = col;\0A}\0A\0Avoid set_rgba(vec4 col, out vec4 outcol)\0A{\0A\09outcol = col;\0A}\0A\0Avoid set_value_zero(out float outval)\0A{\0A\09outval = 0.0;\0A}\0A\0Avoid set_value_one(out float outval)\0A{\0A\09outval = 1.0;\0A}\0A\0Avoid set_rgb_zero(out vec3 outval)\0A{\0A\09outval = vec3(0.0);\0A}\0A\0Avoid set_rgb_one(out vec3 outval)\0A{\0A\09outval = vec3(1.0);\0A}\0A\0Avoid set_rgba_zero(out vec4 outval)\0A{\0A\09outval = vec4(0.0);\0A}\0A\0Avoid set_rgba_one(out vec4 outval)\0A{\0A\09outval = vec4(1.0);\0A}\0A\0Avoid brightness_contrast(vec4 col, float brightness, float contrast, out vec4 outcol)\0A{\0A\09float a = 1.0 + contrast;\0A\09float b = brightness - contrast*0.5;\0A\0A\09outcol.r = max(a*col.r + b, 0.0);\0A\09outcol.g = max(a*col.g + b, 0.0);\0A\09outcol.b = max(a*col.b + b, 0.0);\0A\09outcol.a = col.a;\0A}\0A\0Avoid mix_blend(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol = mix(col1, col2, fac);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_add(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol = mix(col1, col1 + col2, fac);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_mult(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol = mix(col1, col1 * col2, fac);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_screen(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09outcol = vec4(1.0) - (vec4(facm) + fac*(vec4(1.0) - col2))*(vec4(1.0) - col1);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_overlay(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09outcol = col1;\0A\0A\09if(outcol.r < 0.5)\0A\09\09outcol.r *= facm + 2.0*fac*col2.r;\0A\09else\0A\09\09outcol.r = 1.0 - (facm + 2.0*fac*(1.0 - col2.r))*(1.0 - outcol.r);\0A\0A\09if(outcol.g < 0.5)\0A\09\09outcol.g *= facm + 2.0*fac*col2.g;\0A\09else\0A\09\09outcol.g = 1.0 - (facm + 2.0*fac*(1.0 - col2.g))*(1.0 - outcol.g);\0A\0A\09if(outcol.b < 0.5)\0A\09\09outcol.b *= facm + 2.0*fac*col2.b;\0A\09else\0A\09\09outcol.b = 1.0 - (facm + 2.0*fac*(1.0 - col2.b))*(1.0 - outcol.b);\0A}\0A\0Avoid mix_sub(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol = mix(col1, col1 - col2, fac);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_div(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09outcol = col1;\0A\0A\09if(col2.r != 0.0) outcol.r = facm*outcol.r + fac*outcol.r/col2.r;\0A\09if(col2.g != 0.0) outcol.g = facm*outcol.g + fac*outcol.g/col2.g;\0A\09if(col2.b != 0.0) outcol.b = facm*outcol.b + fac*outcol.b/col2.b;\0A}\0A\0Avoid mix_diff(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol = mix(col1, abs(col1 - col2), fac);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_dark(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol.rgb = min(col1.rgb, col2.rgb*fac);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_light(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol.rgb = max(col1.rgb, col2.rgb*fac);\0A\09outcol.a = col1.a;\0A}\0A\0Avoid mix_dodge(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09outcol = col1;\0A\0A\09if(outcol.r != 0.0) {\0A\09\09float tmp = 1.0 - fac*col2.r;\0A\09\09if(tmp <= 0.0)\0A\09\09\09outcol.r = 1.0;\0A\09\09else if((tmp = outcol.r/tmp) > 1.0)\0A\09\09\09outcol.r = 1.0;\0A\09\09else\0A\09\09\09outcol.r = tmp;\0A\09}\0A\09if(outcol.g != 0.0) {\0A\09\09float tmp = 1.0 - fac*col2.g;\0A\09\09if(tmp <= 0.0)\0A\09\09\09outcol.g = 1.0;\0A\09\09else if((tmp = outcol.g/tmp) > 1.0)\0A\09\09\09outcol.g = 1.0;\0A\09\09else\0A\09\09\09outcol.g = tmp;\0A\09}\0A\09if(outcol.b != 0.0) {\0A\09\09float tmp = 1.0 - fac*col2.b;\0A\09\09if(tmp <= 0.0)\0A\09\09\09outcol.b = 1.0;\0A\09\09else if((tmp = outcol.b/tmp) > 1.0)\0A\09\09\09outcol.b = 1.0;\0A\09\09else\0A\09\09\09outcol.b = tmp;\0A\09}\0A}\0A\0Avoid mix_burn(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float tmp, facm = 1.0 - fac;\0A\0A\09outcol = col1;\0A\0A\09tmp = facm + fac*col2.r;\0A\09if(tmp <= 0.0)\0A\09\09outcol.r = 0.0;\0A\09else if((tmp = (1.0 - (1.0 - outcol.r)/tmp)) < 0.0)\0A\09\09outcol.r = 0.0;\0A\09else if(tmp > 1.0)\0A\09\09outcol.r = 1.0;\0A\09else\0A\09\09outcol.r = tmp;\0A\0A\09tmp = facm + fac*col2.g;\0A\09if(tmp <= 0.0)\0A\09\09outcol.g = 0.0;\0A\09else if((tmp = (1.0 - (1.0 - outcol.g)/tmp)) < 0.0)\0A\09\09outcol.g = 0.0;\0A\09else if(tmp > 1.0)\0A\09\09outcol.g = 1.0;\0A\09else\0A\09\09outcol.g = tmp;\0A\0A\09tmp = facm + fac*col2.b;\0A\09if(tmp <= 0.0)\0A\09\09outcol.b = 0.0;\0A\09else if((tmp = (1.0 - (1.0 - outcol.b)/tmp)) < 0.0)\0A\09\09outcol.b = 0.0;\0A\09else if(tmp > 1.0)\0A\09\09outcol.b = 1.0;\0A\09else\0A\09\09outcol.b = tmp;\0A}\0A\0Avoid mix_hue(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09outcol = col1;\0A\0A\09vec4 hsv, hsv2, tmp;\0A\09rgb_to_hsv(col2, hsv2);\0A\0A\09if(hsv2.y != 0.0) {\0A\09\09rgb_to_hsv(outcol, hsv);\0A\09\09hsv.x = hsv2.x;\0A\09\09hsv_to_rgb(hsv, tmp); \0A\0A\09\09outcol = mix(outcol, tmp, fac);\0A\09\09outcol.a = col1.a;\0A\09}\0A}\0A\0Avoid mix_sat(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09outcol = col1;\0A\0A\09vec4 hsv, hsv2;\0A\09rgb_to_hsv(outcol, hsv);\0A\0A\09if(hsv.y != 0.0) {\0A\09\09rgb_to_hsv(col2, hsv2);\0A\0A\09\09hsv.y = facm*hsv.y + fac*hsv2.y;\0A\09\09hsv_to_rgb(hsv, outcol);\0A\09}\0A}\0A\0Avoid mix_val(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09vec4 hsv, hsv2;\0A\09rgb_to_hsv(col1, hsv);\0A\09rgb_to_hsv(col2, hsv2);\0A\0A\09hsv.z = facm*hsv.z + fac*hsv2.z;\0A\09hsv_to_rgb(hsv, outcol);\0A}\0A\0Avoid mix_color(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09outcol = col1;\0A\0A\09vec4 hsv, hsv2, tmp;\0A\09rgb_to_hsv(col2, hsv2);\0A\0A\09if(hsv2.y != 0.0) {\0A\09\09rgb_to_hsv(outcol, hsv);\0A\09\09hsv.x = hsv2.x;\0A\09\09hsv.y = hsv2.y;\0A\09\09hsv_to_rgb(hsv, tmp); \0A\0A\09\09outcol = mix(outcol, tmp, fac);\0A\09\09outcol.a = col1.a;\0A\09}\0A}\0A\0Avoid mix_soft(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\09float facm = 1.0 - fac;\0A\0A\09vec4 one= vec4(1.0);\0A\09vec4 scr= one - (one - col2)*(one - col1);\0A\09outcol = facm*col1 + fac*((one - col1)*col2*col1 + col1*scr);\0A}\0A\0Avoid mix_linear(float fac, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09fac = clamp(fac, 0.0, 1.0);\0A\0A\09outcol = col1;\0A\0A\09if(col2.r > 0.5)\0A\09\09outcol.r= col1.r + fac*(2.0*(col2.r - 0.5));\0A\09else\0A\09\09outcol.r= col1.r + fac*(2.0*(col2.r) - 1.0);\0A\0A\09if(col2.g > 0.5)\0A\09\09outcol.g= col1.g + fac*(2.0*(col2.g - 0.5));\0A\09else\0A\09\09outcol.g= col1.g + fac*(2.0*(col2.g) - 1.0);\0A\0A\09if(col2.b > 0.5)\0A\09\09outcol.b= col1.b + fac*(2.0*(col2.b - 0.5));\0A\09else\0A\09\09outcol.b= col1.b + fac*(2.0*(col2.b) - 1.0);\0A}\0A\0Avoid valtorgb(float fac, sampler2D colormap, out vec4 outcol, out float outalpha)\0A{\0A\09outcol = texture2D(colormap, vec2(fac, 0.0));\0A\09outalpha = outcol.a;\0A}\0A\0Avoid rgbtobw(vec4 color, out float outval)  \0A{\0A\09outval = color.r*0.35 + color.g*0.45 + color.b*0.2; /* keep these factors in sync with texture.h:RGBTOBW */\0A}\0A\0Avoid invert(float fac, vec4 col, out vec4 outcol)\0A{\0A\09outcol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\0A\09outcol.w = col.w;\0A}\0A\0Avoid hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outcol)\0A{\0A\09vec4 hsv;\0A\0A\09rgb_to_hsv(col, hsv);\0A\0A\09hsv[0] += (hue - 0.5);\0A\09if(hsv[0]>1.0) hsv[0]-=1.0; else if(hsv[0]<0.0) hsv[0]+= 1.0;\0A\09hsv[1] *= sat;\0A\09if(hsv[1]>1.0) hsv[1]= 1.0; else if(hsv[1]<0.0) hsv[1]= 0.0;\0A\09hsv[2] *= value;\0A\09if(hsv[2]>1.0) hsv[2]= 1.0; else if(hsv[2]<0.0) hsv[2]= 0.0;\0A\0A\09hsv_to_rgb(hsv, outcol);\0A\0A\09outcol = mix(col, outcol, fac);\0A}\0A\0Avoid separate_rgb(vec4 col, out float r, out float g, out float b)\0A{\0A\09r = col.r;\0A\09g = col.g;\0A\09b = col.b;\0A}\0A\0Avoid combine_rgb(float r, float g, float b, out vec4 col)\0A{\0A\09col = vec4(r, g, b, 1.0);\0A}\0A\0Avoid separate_xyz(vec3 vec, out float x, out float y, out float z)\0A{\0A\09x = vec.r;\0A\09y = vec.g;\0A\09z = vec.b;\0A}\0A\0Avoid combine_xyz(float x, float y, float z, out vec3 vec)\0A{\0A\09vec = vec3(x, y, z);\0A}\0A\0Avoid separate_hsv(vec4 col, out float h, out float s, out float v)\0A{\0A\09vec4 hsv;\0A\0A\09rgb_to_hsv(col, hsv);\0A\09h = hsv[0];\0A\09s = hsv[1];\0A\09v = hsv[2];\0A}\0A\0Avoid combine_hsv(float h, float s, float v, out vec4 col)\0A{\0A\09hsv_to_rgb(vec4(h, s, v, 1.0), col);\0A}\0A\0Avoid output_node(vec4 rgb, float alpha, out vec4 outrgb)\0A{\0A\09outrgb = vec4(rgb.rgb, alpha);\0A}\0A\0A/*********** TEXTURES ***************/\0A\0Avoid texture_flip_blend(vec3 vec, out vec3 outvec)\0A{\0A\09outvec = vec.yxz;\0A}\0A\0Avoid texture_blend_lin(vec3 vec, out float outval)\0A{\0A\09outval = (1.0+vec.x)/2.0;\0A}\0A\0Avoid texture_blend_quad(vec3 vec, out float outval)\0A{\0A\09outval = max((1.0+vec.x)/2.0, 0.0);\0A\09outval *= outval;\0A}\0A\0Avoid texture_wood_sin(vec3 vec, out float value, out vec4 color, out vec3 normal)\0A{\0A\09float a = sqrt(vec.x*vec.x + vec.y*vec.y + vec.z*vec.z)*20.0;\0A\09float wi = 0.5 + 0.5*sin(a);\0A\0A\09value = wi;\0A\09color = vec4(wi, wi, wi, 1.0);\0A\09normal = vec3(0.0, 0.0, 0.0);\0A}\0A\0Avoid texture_image(vec3 vec, sampler2D ima, out float value, out vec4 color, out vec3 normal)\0A{\0A\09color = texture2D(ima, (vec.xy + vec2(1.0, 1.0))*0.5);\0A\09value = color.a;\0A\0A\09normal.x = 2.0*(color.r - 0.5);\0A\09normal.y = 2.0*(0.5 - color.g);\0A\09normal.z = 2.0*(color.b - 0.5);\0A}\0A\0A/************* MTEX *****************/\0A\0Avoid texco_orco(vec3 attorco, out vec3 orco)\0A{\0A\09orco = attorco;\0A}\0A\0Avoid texco_uv(vec2 attuv, out vec3 uv)\0A{\0A\09/* disabled for now, works together with leaving out mtex_2d_mapping\0A\09   uv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0); */\0A\09uv = vec3(attuv, 0.0);\0A}\0A\0Avoid texco_norm(vec3 normal, out vec3 outnormal)\0A{\0A\09/* corresponds to shi->orn, which is negated so cancels\0A\09   out blender normal negation */\0A\09outnormal = normalize(normal);\0A}\0A\0Avoid texco_tangent(vec4 tangent, out vec3 outtangent)\0A{\0A\09outtangent = normalize(tangent.xyz);\0A}\0A\0Avoid texco_global(mat4 viewinvmat, vec3 co, out vec3 global)\0A{\0A\09global = (viewinvmat*vec4(co, 1.0)).xyz;\0A}\0A\0Avoid texco_object(mat4 viewinvmat, mat4 obinvmat, vec3 co, out vec3 object)\0A{\0A\09object = (obinvmat*(viewinvmat*vec4(co, 1.0))).xyz;\0A}\0A\0Avoid texco_refl(vec3 vn, vec3 view, out vec3 ref)\0A{\0A\09ref = view - 2.0*dot(vn, view)*vn;\0A}\0A\0Avoid shade_norm(vec3 normal, out vec3 outnormal)\0A{\0A\09/* blender render normal is negated */\0A\09outnormal = -normalize(normal);\0A}\0A\0Avoid mtex_rgb_blend(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09incol = fact*texcol + facm*outcol;\0A}\0A\0Avoid mtex_rgb_mul(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09incol = (facm + fact*texcol)*outcol;\0A}\0A\0Avoid mtex_rgb_screen(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09incol = vec3(1.0) - (vec3(facm) + fact*(vec3(1.0) - texcol))*(vec3(1.0) - outcol);\0A}\0A\0Avoid mtex_rgb_overlay(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09if(outcol.r < 0.5)\0A\09\09incol.r = outcol.r*(facm + 2.0*fact*texcol.r);\0A\09else\0A\09\09incol.r = 1.0 - (facm + 2.0*fact*(1.0 - texcol.r))*(1.0 - outcol.r);\0A\0A\09if(outcol.g < 0.5)\0A\09\09incol.g = outcol.g*(facm + 2.0*fact*texcol.g);\0A\09else\0A\09\09incol.g = 1.0 - (facm + 2.0*fact*(1.0 - texcol.g))*(1.0 - outcol.g);\0A\0A\09if(outcol.b < 0.5)\0A\09\09incol.b = outcol.b*(facm + 2.0*fact*texcol.b);\0A\09else\0A\09\09incol.b = 1.0 - (facm + 2.0*fact*(1.0 - texcol.b))*(1.0 - outcol.b);\0A}\0A\0Avoid mtex_rgb_sub(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09incol = -fact*facg*texcol + outcol;\0A}\0A\0Avoid mtex_rgb_add(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09incol = fact*facg*texcol + outcol;\0A}\0A\0Avoid mtex_rgb_div(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09if(texcol.r != 0.0) incol.r = facm*outcol.r + fact*outcol.r/texcol.r;\0A\09if(texcol.g != 0.0) incol.g = facm*outcol.g + fact*outcol.g/texcol.g;\0A\09if(texcol.b != 0.0) incol.b = facm*outcol.b + fact*outcol.b/texcol.b;\0A}\0A\0Avoid mtex_rgb_diff(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09incol = facm*outcol + fact*abs(texcol - outcol);\0A}\0A\0Avoid mtex_rgb_dark(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm, col;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09incol.r = min(outcol.r, texcol.r) * fact + outcol.r * facm;\0A\09incol.g = min(outcol.g, texcol.g) * fact + outcol.g * facm;\0A\09incol.b = min(outcol.b, texcol.b) * fact + outcol.b * facm;\0A}\0A\0Avoid mtex_rgb_light(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm, col;\0A\0A\09fact *= facg;\0A\0A\09col = fact*texcol.r;\0A\09if(col > outcol.r) incol.r = col; else incol.r = outcol.r;\0A\09col = fact*texcol.g;\0A\09if(col > outcol.g) incol.g = col; else incol.g = outcol.g;\0A\09col = fact*texcol.b;\0A\09if(col > outcol.b) incol.b = col; else incol.b = outcol.b;\0A}\0A\0Avoid mtex_rgb_hue(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09vec4 col;\0A\0A\09mix_hue(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\0A\09incol.rgb = col.rgb;\0A}\0A\0Avoid mtex_rgb_sat(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09vec4 col;\0A\0A\09mix_sat(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\0A\09incol.rgb = col.rgb;\0A}\0A\0Avoid mtex_rgb_val(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09vec4 col;\0A\0A\09mix_val(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\0A\09incol.rgb = col.rgb;\0A}\0A\0Avoid mtex_rgb_color(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09vec4 col;\0A\0A\09mix_color(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\0A\09incol.rgb = col.rgb;\0A}\0A\0Avoid mtex_rgb_soft(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09float facm;\0A\0A\09fact *= facg;\0A\09facm = 1.0-fact;\0A\0A\09vec3 one = vec3(1.0);\0A\09vec3 scr = one - (one - texcol)*(one - outcol);\0A\09incol = facm*outcol + fact*((one - texcol)*outcol*texcol + outcol*scr);\0A}\0A\0Avoid mtex_rgb_linear(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\0A{\0A\09fact *= facg;\0A\0A\09if(texcol.r > 0.5)\0A\09\09incol.r = outcol.r + fact*(2.0*(texcol.r - 0.5));\0A\09else\0A\09\09incol.r = outcol.r + fact*(2.0*(texcol.r) - 1.0);\0A\0A\09if(texcol.g > 0.5)\0A\09\09incol.g = outcol.g + fact*(2.0*(texcol.g - 0.5));\0A\09else\0A\09\09incol.g = outcol.g + fact*(2.0*(texcol.g) - 1.0);\0A\0A\09if(texcol.b > 0.5)\0A\09\09incol.b = outcol.b + fact*(2.0*(texcol.b - 0.5));\0A\09else\0A\09\09incol.b = outcol.b + fact*(2.0*(texcol.b) - 1.0);\0A}\0A\0Avoid mtex_value_vars(inout float fact, float facg, out float facm)\0A{\0A\09fact *= abs(facg);\0A\09facm = 1.0-fact;\0A\0A\09if(facg < 0.0) {\0A\09\09float tmp = fact;\0A\09\09fact = facm;\0A\09\09facm = tmp;\0A\09}\0A}\0A\0Avoid mtex_value_blend(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09incol = fact*texcol + facm*outcol;\0A}\0A\0Avoid mtex_value_mul(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09facm = 1.0 - facg;\0A\09incol = (facm + fact*texcol)*outcol;\0A}\0A\0Avoid mtex_value_screen(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09facm = 1.0 - facg;\0A\09incol = 1.0 - (facm + fact*(1.0 - texcol))*(1.0 - outcol);\0A}\0A\0Avoid mtex_value_sub(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09fact = -fact;\0A\09incol = fact*texcol + outcol;\0A}\0A\0Avoid mtex_value_add(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09fact = fact;\0A\09incol = fact*texcol + outcol;\0A}\0A\0Avoid mtex_value_div(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09if(texcol != 0.0)\0A\09\09incol = facm*outcol + fact*outcol/texcol;\0A\09else\0A\09\09incol = 0.0;\0A}\0A\0Avoid mtex_value_diff(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09incol = facm*outcol + fact*abs(texcol - outcol);\0A}\0A\0Avoid mtex_value_dark(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09incol = facm*outcol + fact*min(outcol, texcol);\0A}\0A\0Avoid mtex_value_light(float outcol, float texcol, float fact, float facg, out float incol)\0A{\0A\09float facm;\0A\09mtex_value_vars(fact, facg, facm);\0A\0A\09float col = fact*texcol;\0A\09if(col > outcol) incol = col; else incol = outcol;\0A}\0A\0Avoid mtex_value_clamp_positive(float fac, out float outfac)\0A{\0A\09outfac = max(fac, 0.0);\0A}\0A\0Avoid mtex_value_clamp(float fac, out float outfac)\0A{\0A\09outfac = clamp(fac, 0.0, 1.0);\0A}\0A\0Avoid mtex_har_divide(float har, out float outhar)\0A{\0A\09outhar = har/128.0;\0A}\0A\0Avoid mtex_har_multiply_clamp(float har, out float outhar)\0A{\0A\09har *= 128.0;\0A\0A\09if(har < 1.0) outhar = 1.0;\0A\09else if(har > 511.0) outhar = 511.0;\0A\09else outhar = har;\0A}\0A\0Avoid mtex_alpha_from_col(vec4 col, out float alpha)\0A{\0A\09alpha = col.a;\0A}\0A\0Avoid mtex_alpha_to_col(vec4 col, float alpha, out vec4 outcol)\0A{\0A\09outcol = vec4(col.rgb, alpha);\0A}\0A\0Avoid mtex_rgbtoint(vec4 rgb, out float intensity)\0A{\0A\09intensity = dot(vec3(0.35, 0.45, 0.2), rgb.rgb);\0A}\0A\0Avoid mtex_value_invert(float invalue, out float outvalue)\0A{\0A\09outvalue = 1.0 - invalue;\0A}\0A\0Avoid mtex_rgb_invert(vec4 inrgb, out vec4 outrgb)\0A{\0A\09outrgb = vec4(vec3(1.0) - inrgb.rgb, inrgb.a);\0A}\0A\0Avoid mtex_value_stencil(float stencil, float intensity, out float outstencil, out float outintensity)\0A{\0A\09float fact = intensity;\0A\09outintensity = intensity*stencil;\0A\09outstencil = stencil*fact;\0A}\0A\0Avoid mtex_rgb_stencil(float stencil, vec4 rgb, out float outstencil, out vec4 outrgb)\0A{\0A\09float fact = rgb.a;\0A\09outrgb = vec4(rgb.rgb, rgb.a*stencil);\0A\09outstencil = stencil*fact;\0A}\0A\0Avoid mtex_mapping_ofs(vec3 texco, vec3 ofs, out vec3 outtexco)\0A{\0A\09outtexco = texco + ofs;\0A}\0A\0Avoid mtex_mapping_size(vec3 texco, vec3 size, out vec3 outtexco)\0A{\0A\09outtexco = size*texco;\0A}\0A\0Avoid mtex_2d_mapping(vec3 vec, out vec3 outvec)\0A{\0A\09outvec = vec3(vec.xy*0.5 + vec2(0.5), vec.z);\0A}\0A\0Avec3 mtex_2d_mapping(vec3 vec)\0A{\0A\09return vec3(vec.xy*0.5 + vec2(0.5), vec.z);\0A}\0A\0Avoid mtex_image(vec3 texco, sampler2D ima, out float value, out vec4 color)\0A{\0A\09color = texture2D(ima, texco.xy);\0A\09value = 1.0;\0A}\0A\0Avoid mtex_normal(vec3 texco, sampler2D ima, out vec3 normal)\0A{\0A\09// The invert of the red channel is to make\0A\09// the normal map compliant with the outside world.\0A\09// It needs to be done because in Blender\0A\09// the normal used points inward.\0A\09// Should this ever change this negate must be removed.\0A\09vec4 color = texture2D(ima, texco.xy);\0A\09normal = 2.0*(vec3(-color.r, color.g, color.b) - vec3(-0.5, 0.5, 0.5));\0A}\0A\0Avoid mtex_bump_normals_init( vec3 vN, out vec3 vNorg, out vec3 vNacc, out float fPrevMagnitude )\0A{\0A\09vNorg = vN;\0A\09vNacc = vN;\0A\09fPrevMagnitude = 1.0;\0A}\0A\0A/** helper method to extract the upper left 3x3 matrix from a 4x4 matrix */\0Amat3 to_mat3(mat4 m4)\0A{\0A\09mat3 m3;\0A\09m3[0] = m4[0].xyz;\0A\09m3[1] = m4[1].xyz;\0A\09m3[2] = m4[2].xyz;\0A\09return m3;\0A}\0A\0Avoid mtex_bump_init_objspace( vec3 surf_pos, vec3 surf_norm,\0A\09\09\09\09\09\09\09  mat4 mView, mat4 mViewInv, mat4 mObj, mat4 mObjInv, \0A\09\09\09\09\09\09\09  float fPrevMagnitude_in, vec3 vNacc_in,\0A\09\09\09\09\09\09\09  out float fPrevMagnitude_out, out vec3 vNacc_out, \0A\09\09\09\09\09\09\09  out vec3 vR1, out vec3 vR2, out float fDet ) \0A{\0A\09mat3 obj2view = to_mat3(gl_ModelViewMatrix);\0A\09mat3 view2obj = to_mat3(gl_ModelViewMatrixInverse);\0A\09\0A\09vec3 vSigmaS = view2obj * dFdx( surf_pos );\0A\09vec3 vSigmaT = view2obj * dFdy( surf_pos );\0A\09vec3 vN = normalize( surf_norm * obj2view );\0A\0A\09vR1 = cross( vSigmaT, vN );\0A\09vR2 = cross( vN, vSigmaS ) ;\0A\09fDet = dot ( vSigmaS, vR1 );\0A\09\0A\09/* pretransform vNacc (in mtex_bump_apply) using the inverse transposed */\0A\09vR1 = vR1 * view2obj;\0A\09vR2 = vR2 * view2obj;\0A\09vN = vN * view2obj;\0A\09\0A\09float fMagnitude = abs(fDet) * length(vN);\0A\09vNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\0A\09fPrevMagnitude_out = fMagnitude;\0A}\0A\0Avoid mtex_bump_init_texturespace( vec3 surf_pos, vec3 surf_norm, \0A\09\09\09\09\09\09\09\09  float fPrevMagnitude_in, vec3 vNacc_in,\0A\09\09\09\09\09\09\09\09  out float fPrevMagnitude_out, out vec3 vNacc_out, \0A\09\09\09\09\09\09\09\09  out vec3 vR1, out vec3 vR2, out float fDet ) \0A{\0A\09vec3 vSigmaS = dFdx( surf_pos );\0A\09vec3 vSigmaT = dFdy( surf_pos );\0A\09vec3 vN = surf_norm; /* normalized interpolated vertex normal */\0A\09\0A\09vR1 = normalize( cross( vSigmaT, vN ) );\0A\09vR2 = normalize( cross( vN, vSigmaS ) );\0A\09fDet = sign( dot(vSigmaS, vR1) );\0A\09\0A\09float fMagnitude = abs(fDet);\0A\09vNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\0A\09fPrevMagnitude_out = fMagnitude;\0A}\0A\0Avoid mtex_bump_init_viewspace( vec3 surf_pos, vec3 surf_norm, \0A\09\09\09\09\09\09\09   float fPrevMagnitude_in, vec3 vNacc_in,\0A\09\09\09\09\09\09\09   out float fPrevMagnitude_out, out vec3 vNacc_out, \0A\09\09\09\09\09\09\09   out vec3 vR1, out vec3 vR2, out float fDet ) \0A{\0A\09vec3 vSigmaS = dFdx( surf_pos );\0A\09vec3 vSigmaT = dFdy( surf_pos );\0A\09vec3 vN = surf_norm; /* normalized interpolated vertex normal */\0A\09\0A\09vR1 = cross( vSigmaT, vN );\0A\09vR2 = cross( vN, vSigmaS ) ;\0A\09fDet = dot ( vSigmaS, vR1 );\0A\09\0A\09float fMagnitude = abs(fDet);\0A\09vNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\0A\09fPrevMagnitude_out = fMagnitude;\0A}\0A\0Avoid mtex_bump_tap3( vec3 texco, sampler2D ima, float hScale, \0A                     out float dBs, out float dBt )\0A{\0A\09vec2 STll = texco.xy;\0A\09vec2 STlr = texco.xy + dFdx(texco.xy) ;\0A\09vec2 STul = texco.xy + dFdy(texco.xy) ;\0A\09\0A\09float Hll,Hlr,Hul;\0A\09rgbtobw( texture2D(ima, STll), Hll );\0A\09rgbtobw( texture2D(ima, STlr), Hlr );\0A\09rgbtobw( texture2D(ima, STul), Hul );\0A\09\0A\09dBs = hScale * (Hlr - Hll);\0A\09dBt = hScale * (Hul - Hll);\0A}\0A\0A#ifdef BUMP_BICUBIC\0A\0Avoid mtex_bump_bicubic( vec3 texco, sampler2D ima, float hScale, \0A                     out float dBs, out float dBt ) \0A{\0A\09float Hl;\0A\09float Hr;\0A\09float Hd;\0A\09float Hu;\0A\09\0A\09vec2 TexDx = dFdx(texco.xy);\0A\09vec2 TexDy = dFdy(texco.xy);\0A \0A\09vec2 STl = texco.xy - 0.5 * TexDx ;\0A\09vec2 STr = texco.xy + 0.5 * TexDx ;\0A\09vec2 STd = texco.xy - 0.5 * TexDy ;\0A\09vec2 STu = texco.xy + 0.5 * TexDy ;\0A\09\0A\09rgbtobw(texture2D(ima, STl), Hl);\0A\09rgbtobw(texture2D(ima, STr), Hr);\0A\09rgbtobw(texture2D(ima, STd), Hd);\0A\09rgbtobw(texture2D(ima, STu), Hu);\0A\09\0A\09vec2 dHdxy = vec2(Hr - Hl, Hu - Hd);\0A\09float fBlend = clamp(1.0-textureQueryLOD(ima, texco.xy).x, 0.0, 1.0);\0A\09if(fBlend!=0.0)\0A\09{\0A\09\09// the derivative of the bicubic sampling of level 0\0A\09\09ivec2 vDim;\0A\09\09vDim = textureSize(ima, 0);\0A\0A\09\09// taking the fract part of the texture coordinate is a hardcoded wrap mode.\0A\09\09// this is acceptable as textures use wrap mode exclusively in 3D view elsewhere in blender. \0A\09\09// this is done so that we can still get a valid texel with uvs outside the 0,1 range\0A\09\09// by texelFetch below, as coordinates are clamped when using this function.\0A\09\09vec2 fTexLoc = vDim*fract(texco.xy) - vec2(0.5, 0.5);\0A\09\09ivec2 iTexLoc = ivec2(floor(fTexLoc));\0A\09\09vec2 t = clamp(fTexLoc - iTexLoc, 0.0, 1.0);\09\09// sat just to be pedantic\0A\0A/*******************************************************************************************\0A * This block will replace the one below when one channel textures are properly supported. *\0A *******************************************************************************************\0A\09\09vec4 vSamplesUL = textureGather(ima, (iTexLoc+ivec2(-1,-1) + vec2(0.5,0.5))/vDim );\0A\09\09vec4 vSamplesUR = textureGather(ima, (iTexLoc+ivec2(1,-1) + vec2(0.5,0.5))/vDim );\0A\09\09vec4 vSamplesLL = textureGather(ima, (iTexLoc+ivec2(-1,1) + vec2(0.5,0.5))/vDim );\0A\09\09vec4 vSamplesLR = textureGather(ima, (iTexLoc+ivec2(1,1) + vec2(0.5,0.5))/vDim );\0A\0A\09\09mat4 H = mat4(vSamplesUL.w, vSamplesUL.x, vSamplesLL.w, vSamplesLL.x,\0A\09\09\09\09\09vSamplesUL.z, vSamplesUL.y, vSamplesLL.z, vSamplesLL.y,\0A\09\09\09\09\09vSamplesUR.w, vSamplesUR.x, vSamplesLR.w, vSamplesLR.x,\0A\09\09\09\09\09vSamplesUR.z, vSamplesUR.y, vSamplesLR.z, vSamplesLR.y);\0A*/\09\0A\09\09ivec2 iTexLocMod = iTexLoc + ivec2(-1, -1);\0A\0A\09\09mat4 H;\0A\09\09\0A\09\09for(int i = 0; i < 4; i++) {\0A\09\09\09for(int j = 0; j < 4; j++) {\0A\09\09\09\09ivec2 iTexTmp = iTexLocMod + ivec2(i,j);\0A\09\09\09\09\0A\09\09\09\09// wrap texture coordinates manually for texelFetch to work on uvs oitside the 0,1 range.\0A\09\09\09\09// this is guaranteed to work since we take the fractional part of the uv above.\0A\09\09\09\09iTexTmp.x = (iTexTmp.x < 0)? iTexTmp.x + vDim.x : ((iTexTmp.x >= vDim.x)? iTexTmp.x - vDim.x : iTexTmp.x);\0A\09\09\09\09iTexTmp.y = (iTexTmp.y < 0)? iTexTmp.y + vDim.y : ((iTexTmp.y >= vDim.y)? iTexTmp.y - vDim.y : iTexTmp.y);\0A\0A\09\09\09\09rgbtobw(texelFetch(ima, iTexTmp, 0), H[i][j]);\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09\09float x = t.x, y = t.y;\0A\09\09float x2 = x * x, x3 = x2 * x, y2 = y * y, y3 = y2 * y;\0A\0A\09\09vec4 X = vec4(-0.5*(x3+x)+x2,\09\091.5*x3-2.5*x2+1,\09-1.5*x3+2*x2+0.5*x,\09\090.5*(x3-x2));\0A\09\09vec4 Y = vec4(-0.5*(y3+y)+y2,\09\091.5*y3-2.5*y2+1,\09-1.5*y3+2*y2+0.5*y,\09\090.5*(y3-y2));\0A\09\09vec4 dX = vec4(-1.5*x2+2*x-0.5,\09\094.5*x2-5*x,\09\09\09-4.5*x2+4*x+0.5,\09\091.5*x2-x);\0A\09\09vec4 dY = vec4(-1.5*y2+2*y-0.5,\09\094.5*y2-5*y,\09\09\09-4.5*y2+4*y+0.5,\09\091.5*y2-y);\0A\09\0A\09\09// complete derivative in normalized coordinates (mul by vDim)\0A\09\09vec2 dHdST = vDim * vec2(dot(Y, H * dX), dot(dY, H * X));\0A\0A\09\09// transform derivative to screen-space\0A\09\09vec2 dHdxy_bicubic = vec2( dHdST.x * TexDx.x + dHdST.y * TexDx.y,\0A\09\09\09\09\09\09\09\09   dHdST.x * TexDy.x + dHdST.y * TexDy.y );\0A\0A\09\09// blend between the two\0A\09\09dHdxy = dHdxy*(1-fBlend) + dHdxy_bicubic*fBlend;\0A\09}\0A\0A\09dBs = hScale * dHdxy.x;\0A\09dBt = hScale * dHdxy.y;\0A}\0A\0A#endif\0A\0Avoid mtex_bump_tap5( vec3 texco, sampler2D ima, float hScale, \0A                     out float dBs, out float dBt ) \0A{\0A\09vec2 TexDx = dFdx(texco.xy);\0A\09vec2 TexDy = dFdy(texco.xy);\0A\0A\09vec2 STc = texco.xy;\0A\09vec2 STl = texco.xy - 0.5 * TexDx ;\0A\09vec2 STr = texco.xy + 0.5 * TexDx ;\0A\09vec2 STd = texco.xy - 0.5 * TexDy ;\0A\09vec2 STu = texco.xy + 0.5 * TexDy ;\0A\09\0A\09float Hc,Hl,Hr,Hd,Hu;\0A\09rgbtobw( texture2D(ima, STc), Hc );\0A\09rgbtobw( texture2D(ima, STl), Hl );\0A\09rgbtobw( texture2D(ima, STr), Hr );\0A\09rgbtobw( texture2D(ima, STd), Hd );\0A\09rgbtobw( texture2D(ima, STu), Hu );\0A\09\0A\09dBs = hScale * (Hr - Hl);\0A\09dBt = hScale * (Hu - Hd);\0A}\0A\0Avoid mtex_bump_deriv( vec3 texco, sampler2D ima, float ima_x, float ima_y, float hScale, \0A                     out float dBs, out float dBt ) \0A{\0A\09float s = 1.0;\09\09// negate this if flipped texture coordinate\0A\09vec2 TexDx = dFdx(texco.xy);\0A\09vec2 TexDy = dFdy(texco.xy);\0A\09\0A\09// this variant using a derivative map is described here\0A\09// http://mmikkelsen3d.blogspot.com/2011/07/derivative-maps.html\0A\09vec2 dim = vec2(ima_x, ima_y);\0A\09vec2 dBduv = hScale*dim*(2.0*texture2D(ima, texco.xy).xy-1.0);\0A\09\0A\09dBs = dBduv.x*TexDx.x + s*dBduv.y*TexDx.y;\0A\09dBt = dBduv.x*TexDy.x + s*dBduv.y*TexDy.y;\0A}\0A\0Avoid mtex_bump_apply( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2, vec3 vNacc_in,\0A\09\09\09\09\09  out vec3 vNacc_out, out vec3 perturbed_norm ) \0A{\0A\09vec3 vSurfGrad = sign(fDet) * ( dBs * vR1 + dBt * vR2 );\0A\09\0A\09vNacc_out = vNacc_in - vSurfGrad;\0A\09perturbed_norm = normalize( vNacc_out );\0A}\0A\0Avoid mtex_bump_apply_texspace( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2,\0A                               sampler2D ima, vec3 texco, float ima_x, float ima_y, vec3 vNacc_in,\0A\09\09\09\09\09\09\09   out vec3 vNacc_out, out vec3 perturbed_norm ) \0A{\0A\09vec2 TexDx = dFdx(texco.xy);\0A\09vec2 TexDy = dFdy(texco.xy);\0A\0A\09vec3 vSurfGrad = sign(fDet) * ( \0A\09            dBs / length( vec2(ima_x*TexDx.x, ima_y*TexDx.y) ) * vR1 + \0A\09            dBt / length( vec2(ima_x*TexDy.x, ima_y*TexDy.y) ) * vR2 );\0A\09\09\09\09\0A\09vNacc_out = vNacc_in - vSurfGrad;\0A\09perturbed_norm = normalize( vNacc_out );\0A}\0A\0Avoid mtex_negate_texnormal(vec3 normal, out vec3 outnormal)\0A{\0A\09outnormal = vec3(-normal.x, -normal.y, normal.z);\0A}\0A\0Avoid mtex_nspace_tangent(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\0A{\0A\09vec3 B = tangent.w * cross(normal, tangent.xyz);\0A\0A\09outnormal = texnormal.x*tangent.xyz + texnormal.y*B + texnormal.z*normal;\0A\09outnormal = normalize(outnormal);\0A}\0A\0Avoid mtex_nspace_world(mat4 viewmat, vec3 texnormal, out vec3 outnormal)\0A{\0A\09outnormal = normalize((viewmat*vec4(texnormal, 0.0)).xyz);\0A}\0A\0Avoid mtex_nspace_object(vec3 texnormal, out vec3 outnormal)\0A{\0A\09outnormal = normalize(gl_NormalMatrix * texnormal);\0A}\0A\0Avoid mtex_blend_normal(float norfac, vec3 normal, vec3 newnormal, out vec3 outnormal)\0A{\0A\09outnormal = (1.0 - norfac)*normal + norfac*newnormal;\0A\09outnormal = normalize(outnormal);\0A}\0A\0A/******* MATERIAL *********/\0A\0Avoid lamp_visibility_sun_hemi(vec3 lampvec, out vec3 lv, out float dist, out float visifac)\0A{\0A\09lv = lampvec;\0A\09dist = 1.0;\0A\09visifac = 1.0;\0A}\0A\0Avoid lamp_visibility_other(vec3 co, vec3 lampco, out vec3 lv, out float dist, out float visifac)\0A{\0A\09lv = co - lampco;\0A\09dist = length(lv);\0A\09lv = normalize(lv);\0A\09visifac = 1.0;\0A}\0A\0Avoid lamp_falloff_invlinear(float lampdist, float dist, out float visifac)\0A{\0A\09visifac = lampdist/(lampdist + dist);\0A}\0A\0Avoid lamp_falloff_invsquare(float lampdist, float dist, out float visifac)\0A{\0A\09visifac = lampdist/(lampdist + dist*dist);\0A}\0A\0Avoid lamp_falloff_sliders(float lampdist, float ld1, float ld2, float dist, out float visifac)\0A{\0A\09float lampdistkw = lampdist*lampdist;\0A\0A\09visifac = lampdist/(lampdist + ld1*dist);\0A\09visifac *= lampdistkw/(lampdistkw + ld2*dist*dist);\0A}\0A\0Avoid lamp_falloff_curve(float lampdist, sampler2D curvemap, float dist, out float visifac)\0A{\0A\09visifac = texture2D(curvemap, vec2(dist/lampdist, 0.0)).x;\0A}\0A\0Avoid lamp_visibility_sphere(float lampdist, float dist, float visifac, out float outvisifac)\0A{\0A\09float t= lampdist - dist;\0A\0A\09outvisifac= visifac*max(t, 0.0)/lampdist;\0A}\0A\0Avoid lamp_visibility_spot_square(vec3 lampvec, mat4 lampimat, vec3 lv, out float inpr)\0A{\0A\09if(dot(lv, lampvec) > 0.0) {\0A\09\09vec3 lvrot = (lampimat*vec4(lv, 0.0)).xyz;\0A\09\09float x = max(abs(lvrot.x/lvrot.z), abs(lvrot.y/lvrot.z));\0A\0A\09\09inpr = 1.0/sqrt(1.0 + x*x);\0A\09}\0A\09else\0A\09\09inpr = 0.0;\0A}\0A\0Avoid lamp_visibility_spot_circle(vec3 lampvec, vec3 lv, out float inpr)\0A{\0A\09inpr = dot(lv, lampvec);\0A}\0A\0Avoid lamp_visibility_spot(float spotsi, float spotbl, float inpr, float visifac, out float outvisifac)\0A{\0A\09float t = spotsi;\0A\0A\09if(inpr <= t) {\0A\09\09outvisifac = 0.0;\0A\09}\0A\09else {\0A\09\09t = inpr - t;\0A\0A\09\09/* soft area */\0A\09\09if(spotbl != 0.0)\0A\09\09\09inpr *= smoothstep(0.0, 1.0, t/spotbl);\0A\0A\09\09outvisifac = visifac*inpr;\0A\09}\0A}\0A\0Avoid lamp_visibility_clamp(float visifac, out float outvisifac)\0A{\0A\09outvisifac = (visifac < 0.001)? 0.0: visifac;\0A}\0A\0Avoid shade_view(vec3 co, out vec3 view)\0A{\0A\09/* handle perspective/orthographic */\0A\09view = (gl_ProjectionMatrix[3][3] == 0.0)? normalize(co): vec3(0.0, 0.0, -1.0);\0A}\0A\0Avoid shade_tangent_v(vec3 lv, vec3 tang, out vec3 vn)\0A{\0A\09vec3 c = cross(lv, tang);\0A\09vec3 vnor = cross(c, tang);\0A\0A\09vn = -normalize(vnor);\0A}\0A\0Avoid shade_inp(vec3 vn, vec3 lv, out float inp)\0A{\0A\09inp = dot(vn, lv);\0A}\0A\0Avoid shade_is_no_diffuse(out float is)\0A{\0A\09is = 0.0;\0A}\0A\0Avoid shade_is_hemi(float inp, out float is)\0A{\0A\09is = 0.5*inp + 0.5;\0A}\0A\0Afloat area_lamp_energy(mat4 area, vec3 co, vec3 vn)\0A{\0A\09vec3 vec[4], c[4];\0A\09float rad[4], fac;\0A\09\0A\09vec[0] = normalize(co - area[0].xyz);\0A\09vec[1] = normalize(co - area[1].xyz);\0A\09vec[2] = normalize(co - area[2].xyz);\0A\09vec[3] = normalize(co - area[3].xyz);\0A\0A\09c[0] = normalize(cross(vec[0], vec[1]));\0A\09c[1] = normalize(cross(vec[1], vec[2]));\0A\09c[2] = normalize(cross(vec[2], vec[3]));\0A\09c[3] = normalize(cross(vec[3], vec[0]));\0A\0A\09rad[0] = acos(dot(vec[0], vec[1]));\0A\09rad[1] = acos(dot(vec[1], vec[2]));\0A\09rad[2] = acos(dot(vec[2], vec[3]));\0A\09rad[3] = acos(dot(vec[3], vec[0]));\0A\0A\09fac=  rad[0]*dot(vn, c[0]);\0A\09fac+= rad[1]*dot(vn, c[1]);\0A\09fac+= rad[2]*dot(vn, c[2]);\0A\09fac+= rad[3]*dot(vn, c[3]);\0A\0A\09return max(fac, 0.0);\0A}\0A\0Avoid shade_inp_area(vec3 position, vec3 lampco, vec3 lampvec, vec3 vn, mat4 area, float areasize, float k, out float inp)\0A{\0A\09vec3 co = position;\0A\09vec3 vec = co - lampco;\0A\0A\09if(dot(vec, lampvec) < 0.0) {\0A\09\09inp = 0.0;\0A\09}\0A\09else {\0A\09\09float intens = area_lamp_energy(area, co, vn);\0A\0A\09\09inp = pow(intens*areasize, k);\0A\09}\0A}\0A\0Avoid shade_diffuse_oren_nayer(float nl, vec3 n, vec3 l, vec3 v, float rough, out float is)\0A{\0A\09vec3 h = normalize(v + l);\0A\09float nh = max(dot(n, h), 0.0);\0A\09float nv = max(dot(n, v), 0.0);\0A\09float realnl = dot(n, l);\0A\0A\09if(realnl < 0.0) {\0A\09\09is = 0.0;\0A\09}\0A\09else if(nl < 0.0) {\0A\09\09is = 0.0;\0A\09}\0A\09else {\0A\09\09float vh = max(dot(v, h), 0.0);\0A\09\09float Lit_A = acos(realnl);\0A\09\09float View_A = acos(nv);\0A\0A\09\09vec3 Lit_B = normalize(l - realnl*n);\0A\09\09vec3 View_B = normalize(v - nv*n);\0A\0A\09\09float t = max(dot(Lit_B, View_B), 0.0);\0A\0A\09\09float a, b;\0A\0A\09\09if(Lit_A > View_A) {\0A\09\09\09a = Lit_A;\0A\09\09\09b = View_A;\0A\09\09}\0A\09\09else {\0A\09\09\09a = View_A;\0A\09\09\09b = Lit_A;\0A\09\09}\0A\0A\09\09float A = 1.0 - (0.5*((rough*rough)/((rough*rough) + 0.33)));\0A\09\09float B = 0.45*((rough*rough)/((rough*rough) + 0.09));\0A\0A\09\09b *= 0.95;\0A\09\09is = nl*(A + (B * t * sin(a) * tan(b)));\0A\09}\0A}\0A\0Avoid shade_diffuse_toon(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float is)\0A{\0A\09float rslt = dot(n, l);\0A\09float ang = acos(rslt);\0A\0A\09if(ang < size) is = 1.0;\0A\09else if(ang > (size + tsmooth) || tsmooth == 0.0) is = 0.0;\0A\09else is = 1.0 - ((ang - size)/tsmooth);\0A}\0A\0Avoid shade_diffuse_minnaert(float nl, vec3 n, vec3 v, float darkness, out float is)\0A{\0A\09if(nl <= 0.0) {\0A\09\09is = 0.0;\0A\09}\0A\09else {\0A\09\09float nv = max(dot(n, v), 0.0);\0A\0A\09\09if(darkness <= 1.0)\0A\09\09\09is = nl*pow(max(nv*nl, 0.1), darkness - 1.0);\0A\09\09else\0A\09\09\09is = nl*pow(1.0001 - nv, darkness - 1.0);\0A\09}\0A}\0A\0Afloat fresnel_fac(vec3 view, vec3 vn, float grad, float fac)\0A{\0A\09float t1, t2;\0A\09float ffac;\0A\0A\09if(fac==0.0) {\0A\09\09ffac = 1.0;\0A\09}\0A\09else {\0A\09\09t1= dot(view, vn);\0A\09\09if(t1>0.0)  t2= 1.0+t1;\0A\09\09else t2= 1.0-t1;\0A\0A\09\09t2= grad + (1.0-grad)*pow(t2, fac);\0A\0A\09\09if(t2<0.0) ffac = 0.0;\0A\09\09else if(t2>1.0) ffac = 1.0;\0A\09\09else ffac = t2;\0A\09}\0A\0A\09return ffac;\0A}\0A\0Avoid shade_diffuse_fresnel(vec3 vn, vec3 lv, vec3 view, float fac_i, float fac, out float is)\0A{\0A\09is = fresnel_fac(lv, vn, fac_i, fac);\0A}\0A\0Avoid shade_cubic(float is, out float outis)\0A{\0A\09if(is>0.0 && is<1.0)\0A\09\09outis= smoothstep(0.0, 1.0, is);\0A\09else\0A\09\09outis= is;\0A}\0A\0Avoid shade_visifac(float i, float visifac, float refl, out float outi)\0A{\0A\09/*if(i > 0.0)*/\0A\09\09outi = max(i*visifac*refl, 0.0);\0A\09/*else\0A\09\09outi = i;*/\0A}\0A\0Avoid shade_tangent_v_spec(vec3 tang, out vec3 vn)\0A{\0A\09vn = tang;\0A}\0A\0Avoid shade_add_to_diffuse(float i, vec3 lampcol, vec3 col, out vec3 outcol)\0A{\0A\09if(i > 0.0)\0A\09\09outcol = i*lampcol*col;\0A\09else\0A\09\09outcol = vec3(0.0, 0.0, 0.0);\0A}\0A\0Avoid shade_hemi_spec(vec3 vn, vec3 lv, vec3 view, float spec, float hard, float visifac, out float t)\0A{\0A\09lv += view;\0A\09lv = normalize(lv);\0A\0A\09t = dot(vn, lv);\0A\09t = 0.5*t + 0.5;\0A\0A\09t = visifac*spec*pow(t, hard);\0A}\0A\0Avoid shade_phong_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\0A{\0A\09vec3 h = normalize(l + v);\0A\09float rslt = max(dot(h, n), 0.0);\0A\0A\09specfac = pow(rslt, hard);\0A}\0A\0Avoid shade_cooktorr_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\0A{\0A\09vec3 h = normalize(v + l);\0A\09float nh = dot(n, h);\0A\0A\09if(nh < 0.0) {\0A\09\09specfac = 0.0;\0A\09}\0A\09else {\0A\09\09float nv = max(dot(n, v), 0.0);\0A\09\09float i = pow(nh, hard);\0A\0A\09\09i = i/(0.1+nv);\0A\09\09specfac = i;\0A\09}\0A}\0A\0Avoid shade_blinn_spec(vec3 n, vec3 l, vec3 v, float refrac, float spec_power, out float specfac)\0A{\0A\09if(refrac < 1.0) {\0A\09\09specfac = 0.0;\0A\09}\0A\09else if(spec_power == 0.0) {\0A\09\09specfac = 0.0;\0A\09}\0A\09else {\0A\09\09if(spec_power<100.0)\0A\09\09\09spec_power= sqrt(1.0/spec_power);\0A\09\09else\0A\09\09\09spec_power= 10.0/spec_power;\0A\0A\09\09vec3 h = normalize(v + l);\0A\09\09float nh = dot(n, h);\0A\09\09if(nh < 0.0) {\0A\09\09\09specfac = 0.0;\0A\09\09}\0A\09\09else {\0A\09\09\09float nv = max(dot(n, v), 0.01);\0A\09\09\09float nl = dot(n, l);\0A\09\09\09if(nl <= 0.01) {\0A\09\09\09\09specfac = 0.0;\0A\09\09\09}\0A\09\09\09else {\0A\09\09\09\09float vh = max(dot(v, h), 0.01);\0A\0A\09\09\09\09float a = 1.0;\0A\09\09\09\09float b = (2.0*nh*nv)/vh;\0A\09\09\09\09float c = (2.0*nh*nl)/vh;\0A\0A\09\09\09\09float g = 0.0;\0A\0A\09\09\09\09if(a < b && a < c) g = a;\0A\09\09\09\09else if(b < a && b < c) g = b;\0A\09\09\09\09else if(c < a && c < b) g = c;\0A\0A\09\09\09\09float p = sqrt(((refrac * refrac)+(vh*vh)-1.0));\0A\09\09\09\09float f = (((p-vh)*(p-vh))/((p+vh)*(p+vh)))*(1.0+((((vh*(p+vh))-1.0)*((vh*(p+vh))-1.0))/(((vh*(p-vh))+1.0)*((vh*(p-vh))+1.0))));\0A\09\09\09\09float ang = acos(nh);\0A\0A\09\09\09\09specfac = max(f*g*exp_blender((-(ang*ang)/(2.0*spec_power*spec_power))), 0.0);\0A\09\09\09}\0A\09\09}\0A\09}\0A}\0A\0Avoid shade_wardiso_spec(vec3 n, vec3 l, vec3 v, float rms, out float specfac)\0A{\0A\09vec3 h = normalize(l + v);\0A\09float nh = max(dot(n, h), 0.001);\0A\09float nv = max(dot(n, v), 0.001);\0A\09float nl = max(dot(n, l), 0.001);\0A\09float angle = tan(acos(nh));\0A\09float alpha = max(rms, 0.001);\0A\0A\09specfac= nl * (1.0/(4.0*M_PI*alpha*alpha))*(exp_blender(-(angle*angle)/(alpha*alpha))/(sqrt(nv*nl)));\0A}\0A\0Avoid shade_toon_spec(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float specfac)\0A{\0A\09vec3 h = normalize(l + v);\0A\09float rslt = dot(h, n);\0A\09float ang = acos(rslt);\0A\0A\09if(ang < size) rslt = 1.0;\0A\09else if(ang >= (size + tsmooth) || tsmooth == 0.0) rslt = 0.0;\0A\09else rslt = 1.0 - ((ang - size)/tsmooth);\0A\0A\09specfac = rslt;\0A}\0A\0Avoid shade_spec_area_inp(float specfac, float inp, out float outspecfac)\0A{\0A\09outspecfac = specfac*inp;\0A}\0A\0Avoid shade_spec_t(float shadfac, float spec, float visifac, float specfac, out float t)\0A{\0A\09t = shadfac*spec*visifac*specfac;\0A}\0A\0Avoid shade_add_spec(float t, vec3 lampcol, vec3 speccol, out vec3 outcol)\0A{\0A\09outcol = t*lampcol*speccol;\0A}\0A\0Avoid shade_add(vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09outcol = col1 + col2;\0A}\0A\0Avoid shade_madd(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09outcol = col + col1*col2;\0A}\0A\0Avoid shade_add_clamped(vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09outcol = col1 + max(col2, vec4(0.0, 0.0, 0.0, 0.0));\0A}\0A\0Avoid shade_madd_clamped(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09outcol = col + max(col1*col2, vec4(0.0, 0.0, 0.0, 0.0));\0A}\0A\0Avoid shade_maddf(vec4 col, float f, vec4 col1, out vec4 outcol)\0A{\0A\09outcol = col + f*col1;\0A}\0A\0Avoid shade_mul(vec4 col1, vec4 col2, out vec4 outcol)\0A{\0A\09outcol = col1*col2;\0A}\0A\0Avoid shade_mul_value(float fac, vec4 col, out vec4 outcol)\0A{\0A\09outcol = col*fac;\0A}\0A\0Avoid shade_mul_value_v3(float fac, vec3 col, out vec3 outcol)\0A{\0A\09outcol = col*fac;\0A}\0A\0Avoid shade_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\0A{\0A\09outcol = vec4(col.rgb*obcol.rgb, col.a);\0A}\0A\0Avoid ramp_rgbtobw(vec3 color, out float outval)\0A{\0A\09outval = color.r*0.3 + color.g*0.58 + color.b*0.12;\0A}\0A\0Avoid shade_only_shadow(float i, float shadfac, float energy, vec3 shadcol, out vec3 outshadrgb)\0A{\0A\09outshadrgb = i*energy*(1.0 - shadfac)*(vec3(1.0)-shadcol);\0A}\0A\0Avoid shade_only_shadow_diffuse(vec3 shadrgb, vec3 rgb, vec4 diff, out vec4 outdiff)\0A{\0A\09outdiff = diff - vec4(rgb*shadrgb, 0.0);\0A}\0A\0Avoid shade_only_shadow_specular(vec3 shadrgb, vec3 specrgb, vec4 spec, out vec4 outspec)\0A{\0A\09outspec = spec - vec4(specrgb*shadrgb, 0.0);\0A}\0A\0Avoid shade_clamp_positive(vec4 col, out vec4 outcol)\0A{\0A\09outcol = max(col, vec4(0.0));\0A}\0A\0Avoid test_shadowbuf(vec3 rco, sampler2DShadow shadowmap, mat4 shadowpersmat, float shadowbias, float inp, out float result)\0A{\0A\09if(inp <= 0.0) {\0A\09\09result = 0.0;\0A\09}\0A\09else {\0A\09\09vec4 co = shadowpersmat*vec4(rco, 1.0);\0A\0A\09\09//float bias = (1.5 - inp*inp)*shadowbias;\0A\09\09co.z -= shadowbias*co.w;\0A\09\09\0A\09\09if (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0)\0A\09\09\09result = shadow2DProj(shadowmap, co).x;\0A\09\09else\0A\09\09\09result = 1.0;\0A\09}\0A}\0A\0Avoid test_shadowbuf_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, float inp, out float result)\0A{\0A\09if(inp <= 0.0) {\0A\09\09result = 0.0;\0A\09}\0A\09else {\0A\09\09vec4 co = shadowpersmat*vec4(rco, 1.0);\0A\09\09if (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0) {\0A\09\09\09vec2 moments = texture2DProj(shadowmap, co).rg;\0A\09\09\09float dist = co.z/co.w;\0A\09\09\09float p = 0.0;\0A\09\09\09\0A\09\09\09if(dist <= moments.x)\0A\09\09\09\09p = 1.0;\0A\0A\09\09\09float variance = moments.y - (moments.x*moments.x);\0A\09\09\09variance = max(variance, shadowbias/10.0);\0A\0A\09\09\09float d = moments.x - dist;\0A\09\09\09float p_max = variance / (variance + d*d);\0A\0A\09\09\09// Now reduce light-bleeding by removing the [0, x] tail and linearly rescaling (x, 1]\0A\09\09\09p_max = clamp((p_max-bleedbias)/(1.0-bleedbias), 0.0, 1.0);\0A\0A\09\09\09result = max(p, p_max);\0A\09\09}\0A\09\09else {\0A\09\09\09result = 1.0;\0A\09\09}\0A\09}\0A}\0A\0Avoid shadows_only(vec3 rco, sampler2DShadow shadowmap, mat4 shadowpersmat, float shadowbias, vec3 shadowcolor, float inp, out vec3 result)\0A{\0A\09result = vec3(1.0);\0A\0A\09if(inp > 0.0) {\0A\09\09float shadfac;\0A\0A\09\09test_shadowbuf(rco, shadowmap, shadowpersmat, shadowbias, inp, shadfac);\0A\09\09result -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\0A\09}\0A}\0A\0Avoid shadows_only_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, vec3 shadowcolor, float inp, out vec3 result)\0A{\0A\09result = vec3(1.0);\0A\0A\09if(inp > 0.0) {\0A\09\09float shadfac;\0A\0A\09\09test_shadowbuf_vsm(rco, shadowmap, shadowpersmat, shadowbias, bleedbias, inp, shadfac);\0A\09\09result -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\0A\09}\0A}\0A\0Avoid shade_light_texture(vec3 rco, sampler2D cookie, mat4 shadowpersmat, out vec4 result)\0A{\0A\0A\09vec4 co = shadowpersmat*vec4(rco, 1.0);\0A\0A\09result = texture2DProj(cookie, co);\0A}\0A\0Avoid shade_exposure_correct(vec3 col, float linfac, float logfac, out vec3 outcol)\0A{\0A\09outcol = linfac*(1.0 - exp(col*logfac));\0A}\0A\0Avoid shade_mist_factor(vec3 co, float miststa, float mistdist, float misttype, float misi, out float outfac)\0A{\0A\09float fac, zcor;\0A\0A\09zcor = (gl_ProjectionMatrix[3][3] == 0.0)? length(co): -co[2];\0A\09\0A\09fac = clamp((zcor-miststa)/mistdist, 0.0, 1.0);\0A\09if(misttype == 0.0) fac *= fac;\0A\09else if(misttype == 1.0);\0A\09else fac = sqrt(fac);\0A\0A\09outfac = 1.0 - (1.0-fac)*(1.0-misi);\0A}\0A\0Avoid shade_world_mix(vec3 hor, vec4 col, out vec4 outcol)\0A{\0A\09float fac = clamp(col.a, 0.0, 1.0);\0A\09outcol = vec4(mix(hor, col.rgb, fac), col.a);\0A}\0A\0Avoid shade_alpha_opaque(vec4 col, out vec4 outcol)\0A{\0A\09outcol = vec4(col.rgb, 1.0);\0A}\0A\0Avoid shade_alpha_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\0A{\0A\09outcol = vec4(col.rgb, col.a*obcol.a);\0A}\0A\0A/*********** NEW SHADER UTILITIES **************/\0A\0Afloat fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta)\0A{\0A\09/* compute fresnel reflectance without explicitly computing\0A\09 * the refracted direction */\0A\09float c = abs(dot(Incoming, Normal));\0A\09float g = eta * eta - 1.0 + c * c;\0A\09float result;\0A\0A\09if(g > 0.0) {\0A\09\09g = sqrt(g);\0A\09\09float A =(g - c)/(g + c);\0A\09\09float B =(c *(g + c)- 1.0)/(c *(g - c)+ 1.0);\0A\09\09result = 0.5 * A * A *(1.0 + B * B);\0A\09}\0A\09else {\0A\09\09result = 1.0;  /* TIR (no refracted component) */\0A\09}\0A\0A\09return result;\0A}\0A\0Afloat hypot(float x, float y)\0A{\0A\09return sqrt(x*x + y*y);\0A}\0A\0A/*********** NEW SHADER NODES ***************/\0A\0A#define NUM_LIGHTS 3\0A\0A/* bsdfs */\0A\0Avoid node_bsdf_diffuse(vec4 color, float roughness, vec3 N, out vec4 result)\0A{\0A\09/* ambient light */\0A\09vec3 L = vec3(0.2);\0A\0A\09/* directional lights */\0A\09for(int i = 0; i < NUM_LIGHTS; i++) {\0A\09\09vec3 light_position = gl_LightSource[i].position.xyz;\0A\09\09vec3 light_diffuse = gl_LightSource[i].diffuse.rgb;\0A\0A\09\09float bsdf = max(dot(N, light_position), 0.0);\0A\09\09L += light_diffuse*bsdf;\0A\09}\0A\0A\09result = vec4(L*color.rgb, 1.0);\0A}\0A\0Avoid node_bsdf_glossy(vec4 color, float roughness, vec3 N, out vec4 result)\0A{\0A\09/* ambient light */\0A\09vec3 L = vec3(0.2);\0A\0A\09/* directional lights */\0A\09for(int i = 0; i < NUM_LIGHTS; i++) {\0A\09\09vec3 light_position = gl_LightSource[i].position.xyz;\0A\09\09vec3 H = gl_LightSource[i].halfVector.xyz;\0A\09\09vec3 light_diffuse = gl_LightSource[i].diffuse.rgb;\0A\09\09vec3 light_specular = gl_LightSource[i].specular.rgb;\0A\0A\09\09/* we mix in some diffuse so low roughness still shows up */\0A\09\09float bsdf = 0.5*pow(max(dot(N, H), 0.0), 1.0/roughness);\0A\09\09bsdf += 0.5*max(dot(N, light_position), 0.0);\0A\09\09L += light_specular*bsdf;\0A\09}\0A\0A\09result = vec4(L*color.rgb, 1.0);\0A}\0A\0Avoid node_bsdf_anisotropic(vec4 color, float roughness, float anisotropy, float rotation, vec3 N, vec3 T, out vec4 result)\0A{\0A\09node_bsdf_diffuse(color, 0.0, N, result);\0A}\0A\0Avoid node_bsdf_glass(vec4 color, float roughness, float ior, vec3 N, out vec4 result)\0A{\0A\09node_bsdf_diffuse(color, 0.0, N, result);\0A}\0A\0Avoid node_bsdf_toon(vec4 color, float size, float tsmooth, vec3 N, out vec4 result)\0A{\0A\09node_bsdf_diffuse(color, 0.0, N, result);\0A}\0A\0Avoid node_bsdf_translucent(vec4 color, vec3 N, out vec4 result)\0A{\0A\09node_bsdf_diffuse(color, 0.0, N, result);\0A}\0A\0Avoid node_bsdf_transparent(vec4 color, out vec4 result)\0A{\0A\09/* this isn't right */\0A\09result.r = color.r;\0A\09result.g = color.g;\0A\09result.b = color.b;\0A\09result.a = 0.0;\0A}\0A\0Avoid node_bsdf_velvet(vec4 color, float sigma, vec3 N, out vec4 result)\0A{\0A\09node_bsdf_diffuse(color, 0.0, N, result);\0A}\0A\0Avoid node_subsurface_scattering(vec4 color, float scale, vec3 radius, float sharpen, float texture_blur, vec3 N, out vec4 result)\0A{\0A\09node_bsdf_diffuse(color, 0.0, N, result);\0A}\0A\0Avoid node_bsdf_hair(vec4 color, float offset, float roughnessu, float roughnessv, out vec4 result)\0A{\0A\09result = color;\0A}\0A\0A/* emission */\0A\0Avoid node_emission(vec4 color, float strength, vec3 N, out vec4 result)\0A{\0A\09result = color*strength;\0A}\0A\0A/* closures */\0A\0Avoid node_mix_shader(float fac, vec4 shader1, vec4 shader2, out vec4 shader)\0A{\0A\09shader = mix(shader1, shader2, fac);\0A}\0A\0Avoid node_add_shader(vec4 shader1, vec4 shader2, out vec4 shader)\0A{\0A\09shader = shader1 + shader2;\0A}\0A\0A/* fresnel */\0A\0Avoid node_fresnel(float ior, vec3 N, vec3 I, out float result)\0A{\0A\09/* handle perspective/orthographic */\0A\09vec3 I_view = (gl_ProjectionMatrix[3][3] == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\0A\0A\09float eta = max(ior, 0.00001);\0A\09result = fresnel_dielectric(I_view, N, (gl_FrontFacing)? eta: 1.0/eta);\0A}\0A\0A/* layer_weight */\0A\0Avoid node_layer_weight(float blend, vec3 N, vec3 I, out float fresnel, out float facing)\0A{\0A\09/* fresnel */\0A\09float eta = max(1.0 - blend, 0.00001);\0A\09fresnel = fresnel_dielectric(normalize(I), N, (gl_FrontFacing)? 1.0/eta : eta );\0A\0A\09/* facing */\0A\09facing = abs(dot(normalize(I), N));\0A\09if(blend != 0.5) {\0A\09\09blend = clamp(blend, 0.0, 0.99999);\0A\09\09blend = (blend < 0.5)? 2.0*blend: 0.5/(1.0 - blend);\0A\09\09facing = pow(facing, blend);\0A\09}\0A\09facing = 1.0 - facing;\0A}\0A\0A/* gamma */\0A\0Avoid node_gamma(vec4 col, float gamma, out vec4 outcol)\0A{\0A\09outcol = col;\0A\0A\09if(col.r > 0.0)\0A\09\09outcol.r = compatible_pow(col.r, gamma);\0A\09if(col.g > 0.0)\0A\09\09outcol.g = compatible_pow(col.g, gamma);\0A\09if(col.b > 0.0)\0A\09\09outcol.b = compatible_pow(col.b, gamma);\0A}\0A\0A/* geometry */\0A\0Avoid node_attribute(vec3 attr_uv, out vec4 outcol, out vec3 outvec, out float outf)\0A{\0A\09outcol = vec4(attr_uv, 1.0);\0A\09outvec = attr_uv;\0A\09outf = (attr_uv.x + attr_uv.y + attr_uv.z)/3.0;\0A}\0A\0Avoid node_uvmap(vec3 attr_uv, out vec3 outvec)\0A{\0A\09outvec = attr_uv;\0A}\0A\0Avoid node_geometry(vec3 I, vec3 N, mat4 toworld,\0A\09out vec3 position, out vec3 normal, out vec3 tangent,\0A\09out vec3 true_normal, out vec3 incoming, out vec3 parametric,\0A\09out float backfacing)\0A{\0A\09position = (toworld*vec4(I, 1.0)).xyz;\0A\09normal = (toworld*vec4(N, 0.0)).xyz;\0A\09tangent = vec3(0.0);\0A\09true_normal = normal;\0A\0A\09/* handle perspective/orthographic */\0A\09vec3 I_view = (gl_ProjectionMatrix[3][3] == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\0A\09incoming = -(toworld*vec4(I_view, 0.0)).xyz;\0A\0A\09parametric = vec3(0.0);\0A\09backfacing = (gl_FrontFacing)? 0.0: 1.0;\0A}\0A\0Avoid node_tex_coord(vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat,\0A\09vec3 attr_orco, vec3 attr_uv,\0A\09out vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\0A\09out vec3 camera, out vec3 window, out vec3 reflection)\0A{\0A\09generated = mtex_2d_mapping(attr_orco);\0A\09normal = normalize((obinvmat*(viewinvmat*vec4(N, 0.0))).xyz);\0A\09uv = attr_uv;\0A\09object = (obinvmat*(viewinvmat*vec4(I, 1.0))).xyz;\0A\09camera = I;\0A\09vec4 projvec = gl_ProjectionMatrix * vec4(I, 1.0);\0A\09window = mtex_2d_mapping(projvec.xyz/projvec.w);\0A\0A\09vec3 shade_I;\0A\09shade_view(I, shade_I);\0A\09vec3 view_reflection = reflect(shade_I, normalize(N));\0A\09reflection = (viewinvmat*vec4(view_reflection, 0.0)).xyz;\0A}\0A\0A/* textures */\0A\0Avoid node_tex_gradient(vec3 co, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_checker(vec3 co, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_brick(vec3 co, vec4 color1, vec4 color2, vec4 mortar, float scale, float mortar_size, float bias, float brick_width, float row_height, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_clouds(vec3 co, float size, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_environment(vec3 co, sampler2D ima, out vec4 color)\0A{\0A\09float u = (atan(co.y, co.x) + M_PI)/(2.0*M_PI);\0A\09float v = atan(co.z, hypot(co.x, co.y))/M_PI + 0.5;\0A\0A\09color = texture2D(ima, vec2(u, v));\0A}\0A\0Avoid node_tex_environment_empty(vec3 co, out vec4 color)\0A{\0A\09color = vec4(0.0);\0A}\0A\0Avoid node_tex_image(vec3 co, sampler2D ima, out vec4 color, out float alpha)\0A{\0A\09color = texture2D(ima, co.xy);\0A\09alpha = color.a;\0A}\0A\0Avoid node_tex_image_empty(vec3 co, out vec4 color, out float alpha)\0A{\0A\09color = vec4(0.0);\0A\09alpha = 0.0;\0A}\0A\0Avoid node_tex_magic(vec3 p, float scale, float distortion, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_musgrave(vec3 co, float scale, float detail, float dimension, float lacunarity, float offset, float gain, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_noise(vec3 co, float scale, float detail, float distortion, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_sky(vec3 co, out vec4 color)\0A{\0A\09color = vec4(1.0);\0A}\0A\0Avoid node_tex_voronoi(vec3 co, float scale, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0Avoid node_tex_wave(vec3 co, float scale, float distortion, float detail, float detail_scale, out vec4 color, out float fac)\0A{\0A\09color = vec4(1.0);\0A\09fac = 1.0;\0A}\0A\0A/* light path */\0A\0Avoid node_light_path(\0A\09out float is_camera_ray,\0A\09out float is_shadow_ray,\0A\09out float is_diffuse_ray,\0A\09out float is_glossy_ray,\0A\09out float is_singular_ray,\0A\09out float is_reflection_ray,\0A\09out float is_transmission_ray,\0A\09out float ray_length,\0A\09out float ray_depth,\0A\09out float transparent_depth)\0A{\0A\09is_camera_ray = 1.0;\0A\09is_shadow_ray = 0.0;\0A\09is_diffuse_ray = 0.0;\0A\09is_glossy_ray = 0.0;\0A\09is_singular_ray = 0.0;\0A\09is_reflection_ray = 0.0;\0A\09is_transmission_ray = 0.0;\0A\09ray_length = 1.0;\0A\09ray_depth = 1.0;\0A\09transparent_depth = 1.0;\0A}\0A\0Avoid node_light_falloff(float strength, float tsmooth, out float quadratic, out float linear, out float constant)\0A{\0A\09quadratic = strength;\0A\09linear = strength;\0A\09constant = strength;\0A}\0A\0Avoid node_object_info(out vec3 location, out float object_index, out float material_index, out float random)\0A{\0A\09location = vec3(0.0);\0A\09object_index = 0.0;\0A\09material_index = 0.0;\0A\09random = 0.0;\0A}\0A\0Avoid node_normal_map(float strength, vec4 color, vec3 N, out vec3 result)\0A{\0A\09result = N;\0A}\0A\0Avoid node_bump(float strength, float dist, float height, vec3 N, out vec3 result)\0A{\0A\09result = N;\0A}\0A\0A/* output */\0A\0Avoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 result)\0A{\0A\09result = surface;\0A}\0A\0A/* ********************** matcap style render ******************** */\0A\0Avoid material_preview_matcap(vec4 color, sampler2D ima, vec4 N, vec4 mask, out vec4 result)\0A{\0A\09vec3 normal;\0A\09vec2 tex;\0A\09\0A\09/* remap to 0.0 - 1.0 range. This is done because OpenGL 2.0 clamps colors \0A\09 * between shader stages and we want the full range of the normal */\0A\09normal = vec3(2.0, 2.0, 2.0) * vec3(N.x, N.y, N.z) - vec3(1.0, 1.0, 1.0);\0A\09if (normal.z < 0.0) {\0A\09\09normal.z = 0.0;\0A\09}\0A\09normal = normalize(normal);\0A\0A\09tex.x = 0.5 + 0.49 * normal.x;\0A\09tex.y = 0.5 + 0.49 * normal.y;\0A\09result = texture2D(ima, tex) * mask;\0A}\0A\00", align 16

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 17.0.6"}
