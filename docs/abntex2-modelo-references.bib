@inbook{muchnick:97,
  author = {Steven S. Muchnick},
  title = {Advanced Compiler Design and Implementation},
  publisher = {Morgan Kaufmann},
  year = {1997},
  pages = {481-482},
  edition = {1st}
}  %% DEFINIÇÃO DE ALOCAÇÃO DE REGISTRADORES

@book{briggs:92,
  title={Register allocation via graph coloring},
  author={Briggs, Preston},
  year={1992},
  publisher={Rice University}
}

@ARTICLE{verma:06,
  author={Verma, M. and Marwedel, P.},
  journal={IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, 
  title={Overlay techniques for scratchpad memories in low power embedded processors}, 
  year={2006},
  volume={14},
  number={8},
  pages={802-815},
  doi={10.1109/TVLSI.2006.878469}
} %% PQ A ALOCAÇÃO DE REGISTRADORES É IMPORTANTE, CONSOME MUITA ENERGIA

@article{chaitin:81,
	title = {Register allocation via coloring},
	journal = {Computer Languages},
	volume = {6},
	number = {1},
	pages = {47-57},
	year = {1981},
	issn = {0096-0551},
	doi = {https://doi.org/10.1016/0096-0551(81)90048-5},
	url = {https://www.sciencedirect.com/science/article/pii/0096055181900485},
	author = {Gregory J. Chaitin and Marc A. Auslander and Ashok K. Chandra and John Cocke and Martin E. Hopkins and Peter W. Markstein}
}  %% ARTIGO ORIGINAL SOBRE ALOCAÇÃO COM COLORAÇÃO DE GRAFOS

@inproceedings{chaitin:82,
author = {Chaitin, G. J.},
title = {Register Allocation \& Spilling via Graph Coloring},
year = {1982},
isbn = {0897910745},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800230.806984},
doi = {10.1145/800230.806984},
abstract = {In a previous paper we reported the successful use of graph coloring techniques for doing global register allocation in an experimental PL/I optimizing compiler. When the compiler cannot color the register conflict graph with a number of colors equal to the number of available machine registers, it must add code to spill and reload registers to and from storage. Previously the compiler produced spill code whose quality sometimes left much to be desired, and the ad hoe techniques used took considerable amounts of compile time. We have now discovered how to extend the graph coloring approach so that it naturally solves the spilling problem. Spill decisions are now made on the basis of the register conflict graph and cost estimates of the value of keeping the result of a computation in a register rather than in storage. This new approach produces better object code and takes much less compile time.},
booktitle = {Proceedings of the 1982 SIGPLAN Symposium on Compiler Construction},
pages = {98–105},
numpages = {8},
location = {Boston, Massachusetts, USA},
series = {SIGPLAN '82}
}  %% PRIMEIRA IMPLEMENTAÇÃO EM UM COMPILADOR

@Inbook{karp:72,
	author="Karp, Richard M.",
	editor="Miller, Raymond E.
	and Thatcher, James W.
	and Bohlinger, Jean D.",
	title="Reducibility among Combinatorial Problems",
	bookTitle="Complexity of Computer Computations: Proceedings of a symposium on the Complexity of Computer Computations, held March 20--22, 1972, at the IBM Thomas J. Watson Research Center, Yorktown Heights, New York, and sponsored by the Office of Naval Research, Mathematics Program, IBM World Trade Corporation, and the IBM Research Mathematical Sciences Department",
	year="1972",
	publisher="Springer US",
	address="Boston, MA",
	pages="85--103",
	isbn="978-1-4684-2001-2",
	doi="10.1007/978-1-4684-2001-2_9",
	url="https://doi.org/10.1007/978-1-4684-2001-2_9"
}  %% ARTIGO CARACTERIZANDO A COLORAÇÃO DE GRAFOS COMO NP-COMPLETO

@article{garey:76,
author = {Garey, M. R. and Johnson, D. S.},
title = {The Complexity of Near-Optimal Graph Coloring},
year = {1976},
issue_date = {Jan. 1976},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/321921.321926},
doi = {10.1145/321921.321926},
abstract = {Graph coloring problems, in which one would like to color the vertices of a given graph with a small number of colors so that no two adjacent vertices receive the same color, arise in many applications, including various scheduling and partitioning problems. In this paper the complexity and performance of algorithms which construct such colorings are investigated. For a graph G, let χ(G) denote the minimum possible number of colors required to color G and, for any graph coloring algorithm A, let A(G) denote the number of colors used by A when applied to G. Since the graph coloring problem is known to be “NP-complete,” it is considered unlikely that any efficient algorithm can guarantee A(G) = χ(G) for all input graphs. In this paper it is proved that even coming close to khgr;(G) with a fast algorithm is hard. Specifically, it is shown that if for some constant r &lt; 2 and constant d there exists a polynomial-time algorithm A which guarantees A(G) ≤ r·χ(G) + d, then there also exists a polynomial-time algorithm A which guarantees A(G) = χ(G).},
journal = {J. ACM},
month = {jan},
pages = {43–49},
numpages = {7}
}  %% ARTIGO MOSTRANDO A INCAPACIDADE DE GARANTIR UMA ALOCAÇÃO EFICIENTE COM COLORAÇÃO DE GRAFOS

@inproceedings{darte:06,
author = {Bouchez, Florent and Darte, Alain and Guillon, Christophe and Rastello, Fabrice},
year = {2006},
month = {11},
pages = {283-298},
title = {Register Allocation: What Does the NP-Completeness Proof of Chaitin et al. Really Prove? Or Revisiting Register Allocation: Why and How},
volume = {4382},
isbn = {978-3-540-72520-6},
doi = {10.1007/978-3-540-72521-3_21}
}  %% REVISITA A PROVA DE NP-COMPLETUDE DE CHAITIN, DISCORRE SOBRE OS ELEMENTOS QUE DIFICULTAM A ALOCAÇÃO DE REGISTRADORES E INDICA DIREÇÕES DE PESQUISA

@inproceedings{pereira:06,
author = {Pereira, Fernando and Palsberg, Jens},
year = {2006},
month = {03},
pages = {79-93},
title = {Register Allocation After Classical SSA Elimination is NP-Complete},
isbn = {978-3-540-33045-5},
doi = {10.1007/11690634_6}
}  %% TRABALHO MAIS RECENTE DEMONSTRANDO A NP-COMPLETUDE DA ALOCAÇÃO DE REGISTRADORES

@InProceedings{liberatore:99,
author="Liberatore, Vincenzo
and Farach-Colton, Martin
and Kremer, Ulrich",
editor="J{\"a}hnichen, Stefan",
title="Evaluation of Algorithms for Local Register Allocation",
booktitle="Compiler Construction",
year="1999",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="137--152",
abstract="Local register allocation (LRA) assigns pseudo-registers to actual registers in a basic block so as to minimize the spill cost. In this paper, four different LRA algorithms are compared with respect to the quality of their generated allocations and the execution times of the algorithms themselves. The evaluation is based on a framework that views register allocation as the combination of boundary conditions, LRA, and register assignment. Our study does not address the problem of instruction scheduling in conjunction with register allocation, and we assume that the spill cost depends only on the number and type of load and store operations, but not on their positions within the instruction stream. The paper discusses the first optimum algorithm based on integer linear programming as one of the LRA algorithms. The optimal algorithm also serves as the base line for the quality assessment of generated allocations. In addition, two known heuristics, namely Furthest-First (FF) and Clean-First (CF), and a new heuristic (MIX) are discussed and evaluated. The evaluation is based on thirteen Fortran programs from the fmm, Spec, and Spec95X benchmark suites. An advanced compiler infrastructure (ILOC) was used to generated aggressively optimized, intermediate pseudo-register code for each benchmark program. Each local register allocation method was implemented, and evaluated by simulating the execution of the generated code on a machine with N registers and an instruction set where loads and stores are C times as expensive as any other instruction. Experiments were performed for different values of N and C. The results show that only for large basic blocks the allocation quality gap between the different algorithms is significant. When basic blocks are large, the difference was up to 23{\%}. Overall, the new heuristic (MIX) performed best as compared to the other heuristics, producing allocations within 1{\%} of optimum. All heuristics had running times comparable to live variable analysis, or lower, i.e., were very reasonable. More work will be needed to evaluate the LRA algorithms in the context of more sophisticated global register allocators and source level transformations that potentially increase basic block sizes, including loop unrolling, inlining, and speculative execution (superblocks).",
isbn="978-3-540-49051-7"
}  %% COMPARAÇÃO DE VÁRIAS HEURÍSTICAS A SEREM UTILIZADAS VISANDO OTIMIZAR A ALOCAÇÃO DE REGISTRADORES

@article{bernstein:89,
author = {Bernstein, D. and Golumbic, M. and Mansour, y. and Pinter, R. and Goldin, D. and Krawczyk, H. and Nahshon, I.},
title = {Spill Code Minimization Techniques for Optimizing Compliers},
year = {1989},
issue_date = {July 1989},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/74818.74841},
doi = {10.1145/74818.74841},
abstract = {Global register allocation and spilling is commonly performed by solving a graph coloring problem. In this paper we present a new coherent set of heuristic methods for reducing the amount of spill code generated. This results in more efficient (and shorter) compiled code. Our approach has been compared to both standard and priority-based coloring algorithms, universally outperforming them.In our approach, we extend the capability of the existing algorithms in several ways. First, we use multiple heuristic functions to increase the likelihood that less spill code will be inserted. We have found three complementary heuristic functions which together appear to span a large proportion of good spill decisions. Second, we use a specially tuned greedy heuristic for determining the order of deleting (and hence coloring) the unconstrained vertices. Third, we have developed a “cleaning” technique which avoids some of the insertion of spill code in non-busy regions.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {258–263},
numpages = {6}
}  %% APRESENTA NOVAS HEURÍSTICAS PARA A ESCOLHA DAS VARIÁVEIS QUE IRÃO PARA SPILL

@article{pereira:08,
author = {Quint\~{a}o Pereira, Fernando Magno and Palsberg, Jens},
title = {Register Allocation by Puzzle Solving},
year = {2008},
issue_date = {June 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1379022.1375609},
doi = {10.1145/1379022.1375609},
abstract = {We show that register allocation can be viewed as solving a collection of puzzles. We model the register file as a puzzle board and the program variables as puzzle pieces; pre-coloring and register aliasing fit in naturally. For architectures such as PowerPC, x86, and StrongARM, we can solve the puzzles in polynomial time, and we have augmented the puzzle solver with a simple heuristic for spilling. For SPEC CPU2000, the compilation time of our implementation is as fast as that of the extended version of linear scan used by LLVM, which is the JIT compiler in the openGL stack of Mac OS 10.5. Our implementation produces x86 code that is of similar quality to the code produced by the slower, state-of-the-art iterated register coalescing of George and Appel with the extensions proposed by Smith, Ramsey, and Holloway in 2004.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {216–226},
numpages = {11},
keywords = {puzzle solving, register aliasing, register allocation}
}  %% ESTADO DA ARTE DA ALOCAÇÃO DE REGISTRADORES

@article{lozano:19,
author = {Lozano, Roberto Casta\~{n}eda and Schulte, Christian},
title = {Survey on Combinatorial Register Allocation and Instruction Scheduling},
year = {2019},
issue_date = {May 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {3},
issn = {0360-0300},
url = {https://doi.org/10.1145/3200920},
doi = {10.1145/3200920},
abstract = {Register allocation (mapping variables to processor registers or memory) and instruction scheduling (reordering instructions to increase instruction-level parallelism) are essential tasks for generating efficient assembly code in a compiler. In the past three decades, combinatorial optimization has emerged as an alternative to traditional, heuristic algorithms for these two tasks. Combinatorial optimization approaches can deliver optimal solutions according to a model, can precisely capture trade-offs between conflicting decisions, and are more flexible at the expense of increased compilation time.This article provides an exhaustive literature review and a classification of combinatorial optimization approaches to register allocation and instruction scheduling, with a focus on the techniques that are most applied in this context: integer programming, constraint programming, partitioned Boolean quadratic programming, and enumeration. Researchers in compilers and combinatorial optimization can benefit from identifying developments, trends, and challenges in the area; compiler practitioners may discern opportunities and grasp the potential benefit of applying combinatorial optimization.},
journal = {ACM Comput. Surv.},
month = {jun},
articleno = {62},
numpages = {50},
keywords = {instruction scheduling, register allocation, Combinatorial optimization}
}

@InProceedings{hack:06,
author="Hack, Sebastian
and Grund, Daniel
and Goos, Gerhard",
editor="Mycroft, Alan
and Zeller, Andreas",
title="Register Allocation for Programs in SSA-Form",
booktitle="Compiler Construction",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="247--262",
abstract="As register allocation is one of the most important phases in optimizing compilers, much work has been done to improve its quality and speed. We present a novel register allocation architecture for programs in SSA-form which simplifies register allocation significantly. We investigate certain properties of SSA-programs and their interference graphs, showing that they belong to the class of chordal graphs. This leads to a quadratic-time optimal coloring algorithm and allows for decoupling the tasks of coloring, spilling and coalescing completely. After presenting heuristic methods for spilling and coalescing, we compare our coalescing heuristic to an optimal method based on integer linear programming.",
isbn="978-3-540-33051-6"
}  %% ESTADO DA ARTE

@book{mitchell:97,
  title={Machine Learning},
  author={Mitchell, T.M.},
  isbn={9780070428072},
  lccn={97007692},
  series={McGraw-Hill international editions - computer science series},
  url={https://books.google.com.br/books?id=xOGAngEACAAJ},
  year={1997},
  publisher={McGraw-Hill Education}
}  %% INTRODUÇÃO AO APRENDIZADO DE MÁQUINA

@book{alpaydin:20,
  title={Introduction to Machine Learning, fourth edition},
  author={Alpaydin, E.},
  isbn={9780262043793},
  lccn={2019028373},
  series={Adaptive Computation and Machine Learning series},
  url={https://books.google.com.br/books?id=tZnSDwAAQBAJ},
  year={2020},
  publisher={MIT Press}
}

@article{kotsiantis:06,
author = {Kotsiantis, Sotiris and Zaharakis, I. and Pintelas, P.},
year = {2006},
month = {11},
pages = {159-190},
title = {Machine learning: A review of classification and combining techniques},
volume = {26},
journal = {Artificial Intelligence Review},
doi = {10.1007/s10462-007-9052-3}
}

@InProceedings{mathew:21,
author="Mathew, Amitha
and Amudha, P.
and Sivakumari, S.",
editor="Hassanien, Aboul Ella
and Bhatnagar, Roheet
and Darwish, Ashraf",
title="Deep Learning Techniques: An Overview",
booktitle="Advanced Machine Learning Technologies and Applications",
year="2021",
publisher="Springer Singapore",
address="Singapore",
pages="599--608",
abstract="Deep learning is a class of machine learning whichMathew, Amitha performsAmudha, P. muchSivakumari, S. better on unstructured data. Deep learning techniques are outperforming current machine learning techniques. It enables computational models to learn features progressively from data at multiple levels. The popularity of deep learning amplified as the amount of data available increased as well as the advancement of hardware that provides powerful computers. This article comprises the evolution of deep learning, various approaches to deep learning, architectures of deep learning, methods, and applications.",
isbn="978-981-15-3383-9"
}

@article{sharma:21,
title = {Machine Learning and Deep Learning Applications-A Vision},
journal = {Global Transitions Proceedings},
volume = {2},
number = {1},
pages = {24-28},
year = {2021},
note = {1st International Conference on Advances in Information, Computing and Trends in Data Engineering (AICDE - 2020)},
issn = {2666-285X},
doi = {https://doi.org/10.1016/j.gltp.2021.01.004},
url = {https://www.sciencedirect.com/science/article/pii/S2666285X21000042},
author = {Neha Sharma and Reecha Sharma and Neeru Jindal},
keywords = {Deep neural learning (DL), Machine Learning (ML), Machine intelligence (artificial intelligence-AL)},
abstract = {The application of artificial intelligence is machine learning which is one of the current topics in the computer field as well as for the new COVID-19 pandemic. Researchers have given a lot of input to enhance the precision of machine learning algorithms and lot of work is carried out rapidly to enhance the intelligence of machines. Learning, a natural process in human behaviour that also becomes a vital part of machines as well. Besides this, another concept of deep learning comes to play its major role. Deep neural network (deep learning) is a subgroup of machine learning. Deep learning had been analysed and implemented in various applications and had shown remarkable results thus this field needs wider exploration which can be helpful for further real-world applications. The main objective of this paper is to provide insight survey for machine learning along with deep learning applications in various domains. Also, some applications with new normal COVID-19 blues. A review on already present applications and currently going on applications in several domains, for machine learning along with deep neural learning are exemplified.}
}

@inproceedings{amarasinghe:03,
author = {Stephenson, Mark and Amarasinghe, Saman and Martin, Martin and O'Reilly, Una-May},
title = {Meta Optimization: Improving Compiler Heuristics with Machine Learning},
year = {2003},
isbn = {1581136625},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/781131.781141},
doi = {10.1145/781131.781141},
abstract = {Compiler writers have crafted many heuristics over the years to approximately solve NP-hard problems efficiently. Finding a heuristic that performs well on a broad range of applications is a tedious and difficult process. This paper introduces Meta Optimization, a methodology for automatically fine-tuning compiler heuristics. Meta Optimization uses machine-learning techniques to automatically search the space of compiler heuristics. Our techniques reduce compiler design complexity by relieving compiler writers of the tedium of heuristic tuning. Our machine-learning system uses an evolutionary algorithm to automatically find effective compiler heuristics. We present promising experimental results. In one mode of operation Meta Optimization creates application-specific heuristics which often result in impressive speedups. For hyperblock formation, one optimization we present in this paper, we obtain an average speedup of 23 (up to 73) for the applications in our suite. Furthermore, by evolving a compiler's heuristic over several benchmarks, we can create effective, general-purpose heuristics. The best general-purpose heuristic our system found for hyperblock formation improved performance by an average of 25 on our training set, and 9 on a completely unrelated test set. We demonstrate the efficacy of our techniques on three different optimizations in this paper: hyperblock formation, register allocation, and data prefetching.},
booktitle = {Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation},
pages = {77–90},
numpages = {14},
keywords = {machine learning, genetic programming, priority functions, compiler heuristics},
location = {San Diego, California, USA},
series = {PLDI '03}
}

@INPROCEEDINGS{das:20,
  author={Das, Dibyendu and Ahmad, Shahid Asghar and Kumar, Venkataramanan},
  booktitle={2020 IEEE/ACM 6th Workshop on the LLVM Compiler Infrastructure in HPC (LLVM-HPC) and Workshop on Hierarchical Parallelism for Exascale Computing (HiPar)}, 
  title={Deep Learning-based Approximate Graph-Coloring Algorithm for Register Allocation}, 
  year={2020},
  volume={},
  number={},
  pages={23-32},
  doi={10.1109/LLVMHPCHiPar51896.2020.00008}
}

@inproceedings{venkatakeerthy:23,
author = {VenkataKeerthy, S. and Jain, Siddharth and Kundu, Anilava and Aggarwal, Rohit and Cohen, Albert and Upadrasta, Ramakrishna},
title = {RL4ReAl: Reinforcement Learning for Register Allocation},
year = {2023},
isbn = {9798400700880},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3578360.3580273},
doi = {10.1145/3578360.3580273},
abstract = {We aim to automate decades of research and experience in register allocation, leveraging machine learning. We tackle this problem by embedding a multi-agent reinforcement learning algorithm within LLVM, training it with the state of the art techniques. We formalize the constraints that precisely define the problem for a given instruction-set architecture, while ensuring that the generated code preserves semantic correctness. We also develop a gRPC based framework providing a modular and efficient compiler interface for training and inference. Our approach is architecture independent: we show experimental results targeting Intel x86 and ARM AArch64. Our results match or out-perform the heavily tuned, production-grade register allocators of LLVM.},
booktitle = {Proceedings of the 32nd ACM SIGPLAN International Conference on Compiler Construction},
pages = {133–144},
numpages = {12},
keywords = {Reinforcement Learning, Register Allocation},
location = {Montr\'{e}al, QC, Canada},
series = {CC 2023}
}

@InProceedings{cavazos:06,
author="Cavazos, John
and Moss, J. Eliot B.
and O'Boyle, Michael F. P.",
editor="Mycroft, Alan
and Zeller, Andreas",
title="Hybrid Optimizations: Which Optimization Algorithm to Use?",
booktitle="Compiler Construction",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="124--138",
abstract="We introduce a new class of compiler heuristics: hybrid optimizations. Hybrid optimizations choose dynamically at compile time which optimization algorithm to apply from a set of different algorithms that implement the same optimization. They use a heuristic to predict the most appropriate algorithm for each piece of code being optimized. Specifically, we construct a hybrid register allocator that chooses between linear scan and graph coloring register allocation. Linear scan is more efficient, but sometimes less effective; graph coloring is generally more expensive, but sometimes more effective. Our setting is Java JIT compilation, which makes optimization algorithm efficiency particularly important.",
isbn="978-3-540-33051-6"
}

@inproceedings{briggs2:92,
  title={Rematerialization},
  author={Briggs, Preston and Cooper, Keith D and Torczon, Linda},
  booktitle={Proceedings of the ACM SIGPLAN 1992 conference on Programming language design and implementation},
  pages={311--321},
  year={1992}
}

@article{bergner:97,
author = {Bergner, Peter and Dahl, Peter and Engebretsen, David and O'Keefe, Matthew},
title = {Spill Code Minimization via Interference Region Spilling},
year = {1997},
issue_date = {May 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {5},
issn = {0362-1340},
url = {https://doi.org/10.1145/258916.258941},
doi = {10.1145/258916.258941},
abstract = {Many optimizing compilers perform global register allocation using a Chaitin-style graph coloring algorithm. Live ranges that cannot be allocated to registers are spilled to memory. The amount of code required to spill the live range depends on the spilling heuristic used. Chaitin's spilling heuristic offers some guidance in reducing the amount of spill code produced. However, this heuristic does not allow the partial spilling of live ranges and the reduction in spill code is limited to a local level. In this paper, we present a global technique called interference region spilling that improves the spilling granularity of any local spilling heuristic. Our technique works above the local spilling heuristic, limiting the normal insertion of spill code to a portion of each spilled live range. By partially spilling live ranges, we can achieve large reductions in dynamically executed spill code; up to 75\% in some cases and an average of 33.6\% across the benchmarks tested.},
journal = {SIGPLAN Not.},
month = {may},
pages = {287–295},
numpages = {9}
}

@InProceedings{cooper:98,
author="Cooper, Keith D.
and Taylor Simpson, L.",
editor="Koskimies, Kai",
title="Live range splitting in a graph coloring register allocator",
booktitle="Compiler Construction",
year="1998",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="174--187",
abstract="Graph coloring is the dominant paradigm for global register allocation [8, 7, 4]. Coloring allocators use an interference graph, I,to model conflicts that prevent two values from sharing a register. Nodes in I represent live ranges. An edge between two nodes indicates that they are simultaneously live and thus, cannot share a register. The allocator tries to construct a k-coloring of Z, for k equal to the number of registers on the target machine. If it succeeds, it maps the colors onto the machine registers to produce an allocation. Unfortunately, it may not discover a k-coloring. In that case, it spills some live ranges by saving their values to memory. Early coloring allocators spilled live ranges completely - at each definition and use. This approach often introduces more spill code than necessary. This paper presents a global approach that avoids some spill code by splitting the live range, breaking it into smaller pieces. We are not the first to study this problem. Bergner et al. describe a heuristic called interference region spilling that reduces the amount of code needed to spill a live range [1]. Briggs experimented with an aggressive form of live range splitting; he saw mixed results [3, see Chapter 6]. This paper presents a passive form of live range splitting that uses splitting as an alternative to spilling. The allocator funds regions where splitting breaks the interferences that cause a spill; it uses estimated costs to choose between splitting the live range and spilling it. We present experimental evidence that this technique is effective. We have seen reductions in the amount of dynamic spill overhead as high as 78{\%} for non-trivial routines. Our technique can easily be coupled with Bergner's to create an allocator that makes a cost-based choice between splitting, interference region spilling, and spilling completely for each spilled live range.",
isbn="978-3-540-69724-4"
}


@InProceedings{mnih:16,
  title = 	 {Asynchronous Methods for Deep Reinforcement Learning},
  author = 	 {Mnih, Volodymyr and Badia, Adria Puigdomenech and Mirza, Mehdi and Graves, Alex and Lillicrap, Timothy and Harley, Tim and Silver, David and Kavukcuoglu, Koray},
  booktitle = 	 {Proceedings of The 33rd International Conference on Machine Learning},
  pages = 	 {1928--1937},
  year = 	 {2016},
  editor = 	 {Balcan, Maria Florina and Weinberger, Kilian Q.},
  volume = 	 {48},
  series = 	 {Proceedings of Machine Learning Research},
  address = 	 {New York, New York, USA},
  month = 	 {20--22 Jun},
  publisher =    {PMLR},
  pdf = 	 {http://proceedings.mlr.press/v48/mniha16.pdf},
  url = 	 {https://proceedings.mlr.press/v48/mniha16.html},
  abstract = 	 {We propose a conceptually simple and lightweight framework for deep reinforcement learning that uses asynchronous gradient descent for optimization of deep neural network controllers. We present asynchronous variants of four standard reinforcement learning algorithms and show that parallel actor-learners have a stabilizing effect on training allowing all four methods to successfully train neural network controllers. The best performing method, an asynchronous variant of actor-critic, surpasses the current state-of-the-art on the Atari domain while training for half the time on a single multi-core CPU instead of a GPU. Furthermore, we show that asynchronous actor-critic succeeds on a wide variety of continuous motor control problems as well as on a new task of navigating random 3D mazes using a visual input.}
}

@INPROCEEDINGS{saha:17,

  author={Saha, Biplab Kumar and Connors, Tiffany A. and Rahman, Saami and Qasem, Apan},

  booktitle={2017 IEEE 19th International Conference on High Performance Computing and Communications; IEEE 15th International Conference on Smart City; IEEE 3rd International Conference on Data Science and Systems (HPCC/SmartCity/DSS)}, 

  title={A Machine Learning Approach to Automatic Creation of Architecture-Sensitive Performance Heuristics}, 

  year={2017},

  volume={},

  number={},

  pages={18-25},

  doi={10.1109/HPCC-SmartCity-DSS.2017.3}}

@InProceedings{musliu:13,
author="Musliu, Nysret
and Schwengerer, Martin",
editor="Nicosia, Giuseppe
and Pardalos, Panos",
title="Algorithm Selection for the Graph Coloring Problem",
booktitle="Learning and Intelligent Optimization",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="389--403",
abstract="We present an automated algorithm selection method based on machine learning for the graph coloring problem (GCP). For this purpose, we identify {\$}{\$}78{\$}{\$}78features for this problem and evaluate the performance of six state-of-the-art (meta) heuristics for the GCP. We use the obtained data to train several classification algorithms that are applied to predict on a new instance the algorithm with the highest expected performance. To achieve better performance for the machine learning algorithms, we investigate the impact of parameters, and evaluate different data discretization and feature selection methods. Finally, we evaluate our approach, which exploits the existing GCP techniques and the automated algorithm selection, and compare it with existing heuristic algorithms. Experimental results show that the GCP solver based on machine learning outperforms previous methods on benchmark instances.",
isbn="978-3-642-44973-4"
}

@inproceedings{lemos:19,
author = {Lemos, Henrique and Prates, Marcelo and Avelar, Pedro and Lamb, Luís},
year = {2019},
month = {11},
pages = {879-885},
title = {Graph Colouring Meets Deep Learning: Effective Graph Neural Network Models for Combinatorial Problems},
doi = {10.1109/ICTAI.2019.00125}
}

@article{goudet:22,
title = {A deep learning guided memetic framework for graph coloring problems},
journal = {Knowledge-Based Systems},
volume = {258},
pages = {109986},
year = {2022},
issn = {0950-7051},
doi = {https://doi.org/10.1016/j.knosys.2022.109986},
url = {https://www.sciencedirect.com/science/article/pii/S0950705122010796},
author = {Olivier Goudet and Cyril Grelier and Jin-Kao Hao},
keywords = {Population-based search, GPU-based parallel search, Deep learning, Heuristics, Graph coloring},
abstract = {Given an undirected graph G=(V,E) with a set of vertices V and a set of edges E, a graph coloring problem involves finding a partition of the vertices into different independent sets. In this paper we present a new framework that combines a deep neural network with the best tools of classical heuristics for graph coloring. The proposed method is evaluated on two popular graph coloring problems (vertex coloring and weighted coloring). Computational experiments on well-known benchmark graphs show that the proposed approach is able to obtain highly competitive results for both problems. A study of the contribution of deep learning in the method highlights that it is possible to learn relevant patterns useful to obtain better solutions to graph coloring problems.}
}

@article{schuetz:22,
  title = {Graph coloring with physics-inspired graph neural networks},
  author = {Schuetz, Martin J. A. and Brubaker, J. Kyle and Zhu, Zhihuai and Katzgraber, Helmut G.},
  journal = {Phys. Rev. Res.},
  volume = {4},
  issue = {4},
  pages = {043131},
  numpages = {10},
  year = {2022},
  month = {Nov},
  publisher = {American Physical Society},
  doi = {10.1103/PhysRevResearch.4.043131},
  url = {https://link.aps.org/doi/10.1103/PhysRevResearch.4.043131}
}

@InProceedings{dodaro:22,
author="Dodaro, Carmine
and Ilardi, Davide
and Oneto, Luca
and Ricca, Francesco",
editor="Gottlob, Georg
and Inclezan, Daniela
and Maratea, Marco",
title="Deep Learning for the Generation of Heuristics in Answer Set Programming: A Case Study of Graph Coloring",
booktitle="Logic Programming and Nonmonotonic Reasoning",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="145--158",
abstract="Answer Set Programming (ASP) is a well-established declarative AI formalism for knowledge representation and reasoning. ASP systems were successfully applied to both industrial and academic problems. Nonetheless, their performance can be improved by embedding domain-specific heuristics into their solving process. However, the development of domain-specific heuristics often requires both a deep knowledge of the domain at hand and a good understanding of the fundamental working principles of the ASP solvers. In this paper, we investigate the use of deep learning techniques to automatically generate domain-specific heuristics for ASP solvers targeting the well-known graph coloring problem. Empirical results show that the idea is promising: the performance of the ASP solver wasp can be improved.",
isbn="978-3-031-15707-3"
}

@book{aho:07,
  title={Compilers: Principles, Techniques, and Tools},
  author={Aho, A.V. and Lam, M.S. and Sethi, R. and Ullman, J.D.},
  isbn={9780321547989},
  series={Alternative eText Formats Series},
  url={https://books.google.com.br/books?id=WomBPgAACAAJ},
  year={2007},
  publisher={Addison-Wesley}
}

@misc{llvmdocs:01,
    title = {{The LLVM Compiler Infrastructure}},
    howpublished = {\url{https://llvm.org}},
    note = {Acesso em: 16 de junho de 2023}
}

@misc{speccpu:01,
    title = {{SPEC CPU®2017 Overview / What's New?}},
    howpublished = {\url{https://www.spec.org/cpu2017/Docs/overview.html}},
    note = {Acesso em: 16 de junho de 2023}
}

@MastersThesis{lattner:02,
    author  = {Chris Lattner},
    title   = "{LLVM: An Infrastructure for Multi-Stage Optimization}",
    school  = "{Computer Science Dept., University of Illinois at Urbana-Champaign}",
    year    = {2002},
    address = {Urbana, IL},
    month   = {Dec},
    note    = {{\em See {\tt http://llvm.cs.uiuc.edu}.}}
}

@inproceedings{xavier:12,
author = {Xavier, Tiago and Souza Oliveira, George and Lima, Ewerton and Faustino, Anderson},
year = {2012},
month = {11},
pages = {190-198},
title = {A Detailed Analysis of the LLVM's Register Allocators},
isbn = {978-1-4799-2937-5},
journal = {Proceedings - International Conference of the Chilean Computer Science Society, SCCC},
doi = {10.1109/SCCC.2012.29}
}

@article{mittal:16,
author = {Mittal, Sparsh},
year = {2016},
month = {07},
pages = {},
title = {A Survey of Techniques for Designing and Managing CPU Register File},
volume = {29},
journal = {Concurrency and Computation Practice and Experience},
doi = {10.1002/cpe.3906}
}

@inbook{toy:86,
  title={Computer Hardware/software Architecture},
  author={Toy, W.N. and Zee, B.},
  isbn={9780131635029},
  lccn={85024416},
pages={30},
  url={https://books.google.com.br/books?id=MttQAAAAMAAJ},
  year={1986},
  publisher={Prentice-Hall}
}

@article{allen:70,
  title={Control flow analysis},
  author={Allen, Frances E},
  journal={ACM Sigplan Notices},
  volume={5},
  number={7},
  pages={1--19},
  year={1970},
  publisher={ACM New York, NY, USA}
}

@article{appel:96,
author = {George, Lal and Appel, Andrew W.},
title = {Iterated Register Coalescing},
year = {1996},
issue_date = {May 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/229542.229546},
doi = {10.1145/229542.229546},
abstract = {An important function of any register allocator is to target registers so as to eliminate copy instructions. Graph-coloring register allocation is an elegant approach to this problem. If the source and destination of a move instruction do not interfere, then their nodes can be coalesced in the interference graph. Chaitin's coalescing heuristic could make a graph uncolorable (i.e., introduce spills); Briggs et al. demonstrated a conservative coalescing heuristic that preserves colorability. But Briggs's algorithm is too conservative and leaves too many move instructions in our programs. We show how to interleave coloring reductions with Briggs's coalescing heuristic, leading to an algorithm that is safe but much more aggressive.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {may},
pages = {300–324},
numpages = {25},
keywords = {register coalescing, register allocation, graph coloring, copy propagation}
}

@inproceedings{eisl:16,
  title={Trace-based register allocation in a jit compiler},
  author={Eisl, Josef and Grimmer, Matthias and Simon, Doug and W{\"u}rthinger, Thomas and M{\"o}ssenb{\"o}ck, Hanspeter},
  booktitle={Proceedings of the 13th International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools},
  pages={1--11},
  year={2016}
}

@InProceedings{braun:09,
author="Braun, Matthias
and Hack, Sebastian",
editor="de Moor, Oege
and Schwartzbach, Michael I.",
title="Register Spilling and Live-Range Splitting for SSA-Form Programs",
booktitle="Compiler Construction",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="174--189",
abstract="Register allocation decides which parts of a variable's live range are held in registers and which in memory. The compiler inserts spill code to move the values of variables between registers and memory. Since fetching data from memory is much slower than reading directly from a register, careful spill code insertion is critical for the performance of the compiled program.",
isbn="978-3-642-00722-4"
}

@inproceedings{koes:09,
author = {Koes, David Ryan and Goldstein, Seth Copen},
title = {Register Allocation Deconstructed},
year = {2009},
isbn = {9781605586960},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1543820.1543824},
doi = {10.1145/1543820.1543824},
abstract = {Register allocation is a fundamental part of any optimizing compiler. Effectively managing the limited register resources of the constrained architectures commonly found in embedded systems is essential in order to maximize code quality. In this paper we deconstruct the register allocation problem into distinct components: coalescing, spilling, move insertion, and assignment. Using an optimal register allocation framework, we empirically evaluate the importance of each of the components, the impact of component integration, and the effectiveness of existing heuristics. We evaluate code quality both in terms of code performance and code size and consider four distinct instruction set architectures: ARM, Thumb, x86, and x86-64. The results of our investigation reveal general principles for register allocation design.},
booktitle = {Proceedings of Th 12th International Workshop on Software and Compilers for Embedded Systems},
pages = {21–30},
numpages = {10},
keywords = {register allocation},
location = {Nice, France},
series = {SCOPES '09}
}

@article{cooper:94,
author = {Briggs, Preston and Cooper, Keith D. and Torczon, Linda},
title = {Improvements to Graph Coloring Register Allocation},
year = {1994},
issue_date = {May 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/177492.177575},
doi = {10.1145/177492.177575},
abstract = {We describe two improvements to Chaitin-style graph coloring register allocators. The first, optimistic coloring, uses a stronger heuristic to find a k-coloring for the interference graph. The second extends Chaitin's treatment of rematerialization to handle a larger class of values. These techniques are complementary. Optimistic coloring decreases the number of procedures that require spill code and reduces the amount of spill code when spilling is unavoidable. Rematerialization lowers the cost of spilling some values. This paper describes both of the techniques and our experience building and using register allocators that incorporate them. It provides a detailed description of optimistic coloring and rematerialization. It presents experimental data to show the performance of several versions of the register allocator on a suite of FORTRAN programs. It discusses several insights that we discovered only after repeated implementation of these allocators.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {may},
pages = {428–455},
numpages = {28},
keywords = {code generation, register allocation, graph coloring}
}

@article{callahan:91,
  title={Register allocation via hierarchical graph coloring},
  author={Callahan, David and Koblenz, Brian},
  journal={ACM Sigplan Notices},
  volume={26},
  number={6},
  pages={192--203},
  year={1991},
  publisher={ACM New York, NY, USA}
}

@article{lawler:76,
title = {A note on the complexity of the chromatic number problem},
journal = {Information Processing Letters},
volume = {5},
number = {3},
pages = {66-67},
year = {1976},
issn = {0020-0190},
doi = {https://doi.org/10.1016/0020-0190(76)90065-X},
url = {https://www.sciencedirect.com/science/article/pii/002001907690065X},
author = {E.L. Lawler},
keywords = {Graph, algorithm, chromatic number, complexity}
}

@article{bjorklund:09,
author = {Bj\"{o}rklund, Andreas and Husfeldt, Thore and Koivisto, Mikko},
title = {Set Partitioning via Inclusion-Exclusion},
journal = {SIAM Journal on Computing},
volume = {39},
number = {2},
pages = {546-563},
year = {2009},
doi = {10.1137/070683933},
URL = {https://doi.org/10.1137/070683933},
eprint = {https://doi.org/10.1137/070683933},
abstract = { Given a set N with n elements and a family \$\mathcal{F}\$ of subsets, we show how to partition N into k such subsets in \$2^n n^{O(1)}\$ time. We also consider variations of this problem where the subsets may overlap or are weighted, and we solve the decision, counting, summation, and optimization versions of these problems. Our algorithms are based on the principle of inclusion-exclusion and the zeta transform. In effect we get exact algorithms in \$2^n n^{O(1)}\$ time for several well-studied partition problems including domatic number, chromatic number, maximum k-cut, bin packing, list coloring, and the chromatic polynomial. We also have applications to Bayesian learning with decision graphs and to model-based data clustering. If only polynomial space is available, our algorithms run in time \$3^n n^{O(1)}\$ if membership in \$\mathcal{F}\$ can be decided in polynomial time. We solve chromatic number in \$O(2.2461^n)\$ time and domatic number in \$O(2.8718^n)\$ time. Finally, we present a family of polynomial space approximation algorithms that find a number between \$\chi(G)\$ and \$\lceil(1+\epsilon)\chi(G)\rceil\$ in time \$O(1.2209^n+2.2461^{e^{-\epsilon}n})\$. }
}

@article{10.1145/74818.74843,
author = {Briggs, P. and Cooper, K. D. and Kennedy, K. and Torczon, L.},
title = {Coloring  Heuristics for Register Allocation},
year = {1989},
issue_date = {July 1989},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/74818.74843},
doi = {10.1145/74818.74843},
abstract = {We describe an improvement to a heuristic introduced by Chaitin for use in graph coloring register allocation. Our modified heuristic produces better colorings, with less spill code. It has similar compile-time and implementation requirements. We present experimental data to compare the two methods.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {275–284},
numpages = {10}
}

@inproceedings{briggs:89,
author = {Briggs, P. and Cooper, K. D. and Kennedy, K. and Torczon, L.},
title = {Coloring  Heuristics for Register Allocation},
year = {1989},
isbn = {089791306X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/73141.74843},
doi = {10.1145/73141.74843},
abstract = {We describe an improvement to a heuristic introduced by Chaitin for use in graph coloring register allocation. Our modified heuristic produces better colorings, with less spill code. It has similar compile-time and implementation requirements. We present experimental data to compare the two methods.},
booktitle = {Proceedings of the ACM SIGPLAN 1989 Conference on Programming Language Design and Implementation},
pages = {275–284},
numpages = {10},
location = {Portland, Oregon, USA},
series = {PLDI '89}
}

@article{poletto:99,
author = {Poletto, Massimiliano and Sarkar, Vivek},
title = {Linear Scan Register Allocation},
year = {1999},
issue_date = {Sept. 1999},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {5},
issn = {0164-0925},
url = {https://doi.org/10.1145/330249.330250},
doi = {10.1145/330249.330250},
abstract = {We describe a new algorithm for fast global register allocation called linear scan. This algorithm is not based on graph coloring, but allocates registers to variables in a single linear-time scan of the variables' live ranges. The linear scan algorithm is considerably faster than algorithms based on graph coloring, is simple to implement, and results in code that is almost as efficient as that obtained using more complex and time-consuming register allocators based on graph coloring. The algorithm is of interest in applications where compile time is a concern, such as dynamic compilation systems, “just-in-time” compilers, and interactive development environments.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {sep},
pages = {895–913},
numpages = {19},
keywords = {compilers, code optimization, register allocation}
}

@inproceedings{johansson:01,
  title={Linear scan register allocation in a high-performance erlang compiler},
  author={Johansson, Erik and Sagonas, Konstantinos},
  booktitle={International Symposium on Practical Aspects of Declarative Languages},
  pages={101--119},
  year={2001},
  organization={Springer}
}

@inproceedings{traub:98,
author = {Traub, Omri and Holloway, Glenn and Smith, Michael D.},
title = {Quality and Speed in Linear-Scan Register Allocation},
year = {1998},
isbn = {0897919874},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/277650.277714},
doi = {10.1145/277650.277714},
abstract = {A linear-scan algorithm directs the global allocation of register candidates to registers based on a simple linear sweep over the program being compiled. This approach to register allocation makes sense for systems, such as those for dynamic compilation, where compilation speed is important. In contrast, most commercial and research optimizing compilers rely on a graph-coloring approach to global register allocation. In this paper, we compare the performance of a linear-scan method against a modern graph-coloring method. We implement both register allocators within the Machine SUIF extension of the Stanford SUIF compiler system. Experimental results show that linear scan is much faster than coloring on benchmarks with large numbers of register candidates. We also describe improvements to the linear-scan approach that do not change its linear character, but allow it to produce code of a quality near to that produced by graph coloring.},
booktitle = {Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation},
pages = {142–151},
numpages = {10},
keywords = {binpacking, global register allocation, graph coloring, linear scan},
location = {Montreal, Quebec, Canada},
series = {PLDI '98}
}

@article{scholz:02,
author = {Scholz, Bernhard and Eckstein, Erik},
title = {Register Allocation for Irregular Architectures},
year = {2002},
issue_date = {July 2002},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {37},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/566225.513854},
doi = {10.1145/566225.513854},
abstract = {For irregular architectures global register allocation is still a challenging problem that has not been successfully solved so far. The graph-coloring analogy of traditional approaches does not match the needs of register allocation for such architectures which feature non-orthogonal instruction sets and small register files. This work proposes a fundamentally new approach to global register allocation for irregular architectures. Our approach formulates global allocation as a partitioned boolean quadratic optimization problem (PBQP) that allows generic modeling of processors peculiarities. Because PBQP is NP-complete we present a heuristic that exhibits a nearly linear run-time complexity.We integrated our register allocator with the Infineon Carmel C Compiler which is based on the Open Compiler Environment from Atair Software. A DSP benchmark suite was used to compare the performance of our register allocator with a graph-coloring approach and with an optimal allocation. The experiments show that our new approach performs better than a traditional graph coloring approach for irregular architectures.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {139–148},
numpages = {10},
keywords = {boolean quadratic problem, register allocation}
}

@inproceedings{hames:06,
  title={Nearly optimal register allocation with PBQP},
  author={Hames, Lang and Scholz, Bernhard},
  booktitle={Joint Modular Languages Conference},
  pages={346--361},
  year={2006},
  organization={Springer}
}

@inproceedings{buchwald:11,
  title={SSA-based register allocation with PBQP},
  author={Buchwald, Sebastian and Zwinkau, Andreas and Bersch, Thomas},
  booktitle={Compiler Construction: 20th International Conference, CC 2011, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2011, Saarbr{\"u}cken, Germany, March 26--April 3, 2011. Proceedings 20},
  pages={42--61},
  year={2011},
  organization={Springer}
}

@inproceedings{buchwald:10,
author = {Buchwald, Sebastian and Zwinkau, Andreas},
title = {Instruction Selection by Graph Transformation},
year = {2010},
isbn = {9781605589039},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1878921.1878926},
doi = {10.1145/1878921.1878926},
abstract = {Common generated instruction selections are based on tree pattern matching, but modern and custom architectures feature instructions, which cannot be covered by trees. To overcome this limitation, we are the first to employ graph transformation, the natural generalization of tree rewriting. Currently, the only approach allowing us to pair graph-based instruction selection with linear time complexity is the mapping to the Partitioned Boolean Quadratic Problem (PBQP). We present formal foundations to verify this approach and therewith identify two problems of the common method and resolve them. We confirm the capabilities of PBQP-based instruction selection by a comparison with a finely-tuned hand-written instruction selection.},
booktitle = {Proceedings of the 2010 International Conference on Compilers, Architectures and Synthesis for Embedded Systems},
pages = {31–40},
numpages = {10},
keywords = {instruction selection},
location = {Scottsdale, Arizona, USA},
series = {CASES '10}
}

@inproceedings{eckstein:03,
  title={Code instruction selection based on SSA-graphs},
  author={Eckstein, Erik and K{\"o}nig, Oliver and Scholz, Bernhard},
  booktitle={International Workshop on Software and Compilers for Embedded Systems},
  pages={49--65},
  year={2003},
  organization={Springer}
}

@inproceedings{wimmer:10,
author = {Wimmer, Christian and Franz, Michael},
title = {Linear Scan Register Allocation on SSA Form},
year = {2010},
isbn = {9781605586359},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1772954.1772979},
doi = {10.1145/1772954.1772979},
abstract = {The linear scan algorithm for register allocation provides a good register assignment with a low compilation overhead and is thus frequently used for just-in-time compilers. Although most of these compilers use static single assignment (SSA) form, the algorithm has not yet been applied on SSA form, i.e., SSA form is usually deconstructed before register allocation. However, the structural properties of SSA form can be used to simplify the algorithm.With only one definition per variable, lifetime intervals (the main data structure) can be constructed without data flow analysis. During allocation, some tests of interval intersection can be skipped because SSA form guarantees non-intersection. Finally, deconstruction of SSA form after register allocation can be integrated into the resolution phase of the register allocator without much additional code.We modified the linear scan register allocator of the Java HotSpot client compiler so that it operates on SSA form. The evaluation shows that our simpler and faster version generates equally good or slightly better machine code.},
booktitle = {Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization},
pages = {170–179},
numpages = {10},
keywords = {Java, register allocation, just-in-time compilation, SSA form, lifetime analysis, SSA form deconstruction, linear scan},
location = {Toronto, Ontario, Canada},
series = {CGO '10}
}

@article{wimmer:04,
  title={Linear scan register allocation for the Java HotSpotTM client compiler},
  author={Wimmer, Christian},
  journal={Master's thesis, Johannes Kepler University Linz},
  year={2004}
}

@book{golumbic:04,
  title={Algorithmic graph theory and perfect graphs},
  author={Golumbic, Martin Charles},
  year={2004},
  publisher={Elsevier}
}

@article{dagan:88,
  title={Trapezoid graphs and their coloring},
  author={Dagan, Ido and Golumbic, Martin Charles and Pinter, Ron Yair},
  journal={Discrete Applied Mathematics},
  volume={21},
  number={1},
  pages={35--46},
  year={1988},
  publisher={Elsevier}
}

@misc{rogers:20,
      title={Efficient global register allocation}, 
      author={Ian Rogers},
      year={2020},
      eprint={2011.05608},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@article{wegman:91,
  title={Constant propagation with conditional branches},
  author={Wegman, Mark N and Zadeck, F Kenneth},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={13},
  number={2},
  pages={181--210},
  year={1991},
  publisher={ACM New York, NY, USA}
}

@inproceedings{chow:84,
  title={Register allocation by priority-based coloring},
  author={Chow, Frederick and Hennessy, John},
  booktitle={Proceedings of the 1984 SIGPLAN symposium on Compiler construction},
  pages={222--232},
  year={1984}
}